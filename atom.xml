<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://waltcow.github.io</id>
    <title>waltcow</title>
    <updated>2021-07-27T09:44:44.603Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://waltcow.github.io"/>
    <link rel="self" href="https://waltcow.github.io/atom.xml"/>
    <subtitle>Do have faith in what you&apos;re doing.</subtitle>
    <logo>https://waltcow.github.io/images/avatar.png</logo>
    <icon>https://waltcow.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, waltcow</rights>
    <entry>
        <title type="html"><![CDATA[Kotlin Coroutine Part 3. Composing suspending functions]]></title>
        <id>https://waltcow.github.io/post/kotlin-coroutine-part-3-composing-suspending-functions/</id>
        <link href="https://waltcow.github.io/post/kotlin-coroutine-part-3-composing-suspending-functions/">
        </link>
        <updated>2021-07-27T09:42:50.000Z</updated>
        <summary type="html"><![CDATA[<p>这一节将介绍各种构建suspend函数的方法</p>
]]></summary>
        <content type="html"><![CDATA[<p>这一节将介绍各种构建suspend函数的方法</p>
<!-- more -->
<h2 id="默认的串行执行">默认的串行执行</h2>
<p>假设我们预先定义了两个suspend函数，它们运行着一些比如远程服务调用或计算的逻辑。我们只是假装它们是有用的，在这个例子中，每个函数只是延迟一秒钟作为模拟。</p>
<pre><code class="language-kotlin">suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}
</code></pre>
<p>如果我们需要它们被依次调用 -- 首先是<code>doSomethingUsefulOne</code>，然后是<code>doSomethingUsefulTwo</code>，并计算它们的结果之和，我们该怎么做？在实践中，如果我们用第一个函数的结果来决定是否需要调用第二个函数或决定如何调用，我们就会这样做。</p>
<p>我们使用正常的顺序调用，因为coroutine中的代码，就像普通代码一样，默认是顺序执行的。下面的例子通过测量两个suspend函数的总执行时间作为演示。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val time = measureTimeMillis {
        val one = doSomethingUsefulOne()
        val two = doSomethingUsefulTwo()
        println(&quot;The answer is ${one + two}&quot;)
    }
    println(&quot;Completed in $time ms&quot;)
//sampleEnd    
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}
</code></pre>
<p>运行的输出如下：</p>
<pre><code class="language-text">The answer is 42
Completed in 2017 ms
</code></pre>
<h2 id="使用async进行并发">使用async进行并发</h2>
<p>如果<code>doSomethingUsefulOne</code>和<code>doSomethingUsefulTwo</code>的调用之间没有依赖关系，而我们想同时进行这两个操作来更快地得到答案，怎么办？这就是<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a>发挥作用的地方。</p>
<p>从概念上讲，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a>就像<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a>一样。它启动了一个单独的coroutine，这是一个轻量级的线程，与所有其他的coroutine同时工作。不同的是，<code>launch</code>返回一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>，并且不携带任何结果值，而<code>async</code>返回一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/index.html">Deferred</a>--一个轻量级的非阻塞未来，代表一个承诺，以后提供一个结果。你可以在一个延迟值上使用<code>.await()</code>来获得它的最终结果，但是<code>Deferred</code>也是一个<code>Job</code>，所以你可以在需要时取消它。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val time = measureTimeMillis {
        val one = async { doSomethingUsefulOne() }
        val two = async { doSomethingUsefulTwo() }
        println(&quot;The answer is ${one.await() + two.await()}&quot;)
    }
    println(&quot;Completed in $time ms&quot;)
//sampleEnd    
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}

</code></pre>
<p>运行的输出如下：</p>
<pre><code class="language-text">The answer is 42
Completed in 1017 ms

</code></pre>
<p>这是两倍的速度，因为这两个coroutines是同时执行的。请注意，coroutines的并发性总是显式的。</p>
<h2 id="懒启动的异步">懒启动的异步</h2>
<p>另外，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a>可以通过将其<code>start</code>参数设置为<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y/index.html">CoroutineStart.LAZY</a>而变成懒启动。在这种模式下，只有当<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html">await</a>需要它的结果时，或者它的`Job'的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html">start</a>函数被调用时，它才会启动coroutine。运行下面的例子。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val time = measureTimeMillis {
        val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }
        val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }
        // some computation
        one.start() // start the first one
        two.start() // start the second one
        println(&quot;The answer is ${one.await() + two.await()}&quot;)
    }
    println(&quot;Completed in $time ms&quot;)
//sampleEnd    
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}
</code></pre>
<p>运行的输出如下：</p>
<pre><code class="language-text">The answer is 42
Completed in 1017 ms
</code></pre>
<p>所以，这里定义了两个coroutines，但没有像前面的例子那样执行，而是通过调用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html">start</a>，将具体何时开始执行的控制权交给程序员。我们首先启动 &quot;one&quot;，然后启动 &quot;two&quot;，然后等待各个coroutines的完成。</p>
<p>请注意，如果我们只是在<code>println</code>中调用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html">await</a>，而不先在单个coroutine上调用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html">start</a>，这将导致顺序执行的，因为<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html">await</a>启动coroutine执行并等待其结束，这不是懒启动的预期行为。<code>async(start = CoroutineStart.LAZY)</code>的用例是在计算值涉及暂停功能的情况下替代标准<code>lazy</code>函数。</p>
<h2 id="异步风格的函数">异步风格的函数</h2>
<p>我们可以定义异步风格的函数，使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> coroutine构建器来异步调用<code>doSomethingUsefulOne</code>和<code>doSomethingUsefulTwo</code>，使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html">GlobalScope</a>引用来选择退出结构化并发。我们用&quot;......Async &quot;后缀来命名这类函数，以强调它们使用异步计算，人们需要使用返回的延迟值来获取结果。</p>
<blockquote>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html">GlobalScope</a>是一个精致的API，其中之一将在下面解释，所以你必须明确地选择使用<code>GlobalScope</code>与<code>@OptIn(DelicateCoroutinesApi::class)</code></p>
</blockquote>
<pre><code class="language-kotlin">// The result type of somethingUsefulOneAsync is Deferred&lt;Int&gt;
@OptIn(DelicateCoroutinesApi::class)
fun somethingUsefulOneAsync() = GlobalScope.async {
    doSomethingUsefulOne()
}

// The result type of somethingUsefulTwoAsync is Deferred&lt;Int&gt;
@OptIn(DelicateCoroutinesApi::class)
fun somethingUsefulTwoAsync() = GlobalScope.async {
    doSomethingUsefulTwo()
}
</code></pre>
<p>请注意，这些<code>xxxAsync</code>函数不是<em>suspending</em>函数。它们可以从任何地方使用。然而，使用它们意味着是异步<em>并发</em> 执行。</p>
<p>下面的例子介绍它们在coroutine之外的使用。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlin.system.*

//sampleStart
// note that we don't have `runBlocking` to the right of `main` in this example
fun main() {
    val time = measureTimeMillis {
        // we can initiate async actions outside of a coroutine
        val one = somethingUsefulOneAsync()
        val two = somethingUsefulTwoAsync()
        // but waiting for a result must involve either suspending or blocking.
        // here we use `runBlocking { ... }` to block the main thread while waiting for the result
        runBlocking {
            println(&quot;The answer is ${one.await() + two.await()}&quot;)
        }
    }
    println(&quot;Completed in $time ms&quot;)
}
//sampleEnd

@OptIn(DelicateCoroutinesApi::class)
fun somethingUsefulOneAsync() = GlobalScope.async {
    doSomethingUsefulOne()
}

@OptIn(DelicateCoroutinesApi::class)
fun somethingUsefulTwoAsync() = GlobalScope.async {
    doSomethingUsefulTwo()
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>The answer is 42
Completed in 1175 ms
</code></pre>
<blockquote>
<p>这种带有异步函数的编程风格在这里只是为了说明问题，因为它在其他编程语言中是一种流行的风格。在Kotlin coroutines中使用这种风格是<strong>强烈反对</strong>的，原因如下</p>
</blockquote>
<p>考虑一下，如果在<code>val one = somethingUsefulOneAsync()</code> 和 <code>one.await()</code>表达式之间，代码中出现了一些逻辑错误，程序抛出了一个异常，程序正在进行的操作就会中止。通常情况下，一个全局错误处理程序可以捕获这个异常，为开发者记录和报告这个错误，但程序可以继续进行其他操作。然而，在这里我们看到<code>somethingUsefulOneAsync</code>仍然在后台运行，尽管启动它的操作被中止了。这个问题在结构化并发中不会发生，如下节所示。</p>
<h2 id="使用async进行-结构化并发">使用async进行 结构化并发</h2>
<p>让我们以<a href="#concurrent-using-async">Concurrent using async</a>为例，提取一个函数来并发执行<code>doSomethingUsefulOne</code>和<code>doSomethingUsefulTwo</code>并返回其结果的总和。因为<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> coroutine builder被定义为<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>的扩展，我们需要在作用域中拥有它，这就是<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>函数所提供的。</p>
<pre><code class="language-kotlin">suspend fun concurrentSum(): Int = coroutineScope {
    val one = async { doSomethingUsefulOne() }
    val two = async { doSomethingUsefulTwo() }
    one.await() + two.await()
}
</code></pre>
<p>这样，如果 &quot;concurrentSum &quot;函数的代码出了问题，它抛出了一个异常，所有在其范围内启动的程序都会被取消。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val time = measureTimeMillis {
        println(&quot;The answer is ${concurrentSum()}&quot;)
    }
    println(&quot;Completed in $time ms&quot;)
//sampleEnd    
}

suspend fun concurrentSum(): Int = coroutineScope {
    val one = async { doSomethingUsefulOne() }
    val two = async { doSomethingUsefulTwo() }
    one.await() + two.await()
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}
</code></pre>
<p>从上述`main'函数的输出中可以看出，我们仍然有两个操作的并发执行。</p>
<pre><code class="language-text">The answer is 42
Completed in 1017 ms
</code></pre>
<p>取消总是通过coroutines的层次结构传播。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
    try {
        failedConcurrentSum()
    } catch(e: ArithmeticException) {
        println(&quot;Computation failed with ArithmeticException&quot;)
    }
}

suspend fun failedConcurrentSum(): Int = coroutineScope {
    val one = async&lt;Int&gt; { 
        try {
            delay(Long.MAX_VALUE) // Emulates very long computation
            42
        } finally {
            println(&quot;First child was cancelled&quot;)
        }
    }
    val two = async&lt;Int&gt; { 
        println(&quot;Second child throws an exception&quot;)
        throw ArithmeticException()
    }
    one.await() + two.await()
}

</code></pre>
<p>请注意第一个<code>async</code> 和等待中的父类是如何在其中一个子类（即<code>two</code>）失败时被取消的。</p>
<pre><code class="language-text">Second child throws an exception
First child was cancelled
Computation failed with ArithmeticException
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin Coroutine Part 2. Cancellation and timeouts]]></title>
        <id>https://waltcow.github.io/post/kotlin-coroutine-part-2-cancellation-and-timeouts/</id>
        <link href="https://waltcow.github.io/post/kotlin-coroutine-part-2-cancellation-and-timeouts/">
        </link>
        <updated>2021-07-27T08:32:32.000Z</updated>
        <summary type="html"><![CDATA[<p>本文简单介绍一下 Kotlin Coroutine的取消和超时处理</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文简单介绍一下 Kotlin Coroutine的取消和超时处理</p>
<!-- more -->
<p>在一个长时间运行的应用程序中，你可能需要对你的后台的coroutines进行细粒度的控制。例如，用户可能已经关闭了一个coroutine正在运行着的页面，现在不再需要其结果，可以取消其操作。<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a>函数返回一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>，可以用来取消正在运行的coroutine。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch {
        repeat(1000) { i -&gt;
            println(&quot;job: I'm sleeping $i ...&quot;)
            delay(500L)
        }
    }
    delay(1300L) // delay a bit
    println(&quot;main: I'm tired of waiting!&quot;)
    job.cancel() // cancels the job
    job.join() // waits for job's completion 
    println(&quot;main: Now I can quit.&quot;)
//sampleEnd    
}
</code></pre>
<p>它的输出结果如下</p>
<pre><code class="language-text">job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
main: Now I can quit.
</code></pre>
<p>只要main调用<code>job.cancel</code>，我们就看不到另一个coroutine的任何输出，因为它被取消了。还有一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>的扩展函数<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel-and-join.html">cancelAndJoin</a>，结合了<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel.html">cancel</a>和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html">join</a>的调用。</p>
<h2 id="取消是相互协同的">取消是相互协同的</h2>
<p>Coroutine的取消是<em>相互协同的</em>。Coroutine代码必须在相互协同下才能被取消。<code>kotlinx.coroutines</code>中所有的suspend函数都是<em>可取消的</em>。它们会检查Coroutine程序的取消，并在取消时抛出<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a>。然而，如果一个Coroutine在计算工作中，并且没有检查取消，那么它就不能被取消，就像下面的例子所示。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val startTime = System.currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (i &lt; 5) { // computation loop, just wastes CPU
            // print a message twice a second
            if (System.currentTimeMillis() &gt;= nextPrintTime) {
                println(&quot;job: I'm sleeping ${i++} ...&quot;)
                nextPrintTime += 500L
            }
        }
    }
    delay(1300L) // delay a bit
    println(&quot;main: I'm tired of waiting!&quot;)
    job.cancelAndJoin() // cancels the job and waits for its completion
    println(&quot;main: Now I can quit.&quot;)
//sampleEnd    
}

</code></pre>
<p>运行结果如下：</p>
<pre><code>job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
job: I'm sleeping 3 ...
job: I'm sleeping 4 ...
main: Now I can quit.

</code></pre>
<p>运行上面程序可以看到，即使job在取消后，仍然继续打印 &quot;I'm sleeping&quot;，直到 job在五次反复后自行完成。</p>
<h2 id="让计算中代码可以取消">让计算中代码可以取消</h2>
<p>有两种方法可以使计算代码可取消。第一种是周期性地调用一个检查取消的暂停函数。譬如使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html">yield</a>函数是个不错的选择。另一种是显式地检查取消的状态。让我们试试后一种方法。</p>
<p>用<code>while (isActive)</code>替换前面例子中的<code>while (i &lt; 5)</code>，然后重新运行它。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val startTime = System.currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (isActive) { // cancellable computation loop
            // print a message twice a second
            if (System.currentTimeMillis() &gt;= nextPrintTime) {
                println(&quot;job: I'm sleeping ${i++} ...&quot;)
                nextPrintTime += 500L
            }
        }
    }
    delay(1300L) // delay a bit
    println(&quot;main: I'm tired of waiting!&quot;)
    job.cancelAndJoin() // cancels the job and waits for its completion
    println(&quot;main: Now I can quit.&quot;)
//sampleEnd    
}
</code></pre>
<p>运行结果：</p>
<pre><code>job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
main: Now I can quit.
</code></pre>
<p>正如你所看到的，现在这个循环被取消了。<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html">isActive</a>是通过<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>对象在coroutine内部可用的一个扩展属性。</p>
<h2 id="用-finally关闭占用资源">用 <code>finally</code>关闭占用资源</h2>
<p>可取消的暂停函数在取消时抛出<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a>，可以用常规方式处理。例如，<code>try {...} finally {...}</code>表达式和使用Kotlin的<code>use</code>函数，在一个coroutine被取消时正常执行它们的最终处理动作。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch {
        try {
            repeat(1000) { i -&gt;
                println(&quot;job: I'm sleeping $i ...&quot;)
                delay(500L)
            }
        } finally {
            println(&quot;job: I'm running finally&quot;)
        }
    }
    delay(1300L) // delay a bit
    println(&quot;main: I'm tired of waiting!&quot;)
    job.cancelAndJoin() // cancels the job and waits for its completion
    println(&quot;main: Now I can quit.&quot;)
//sampleEnd    
}

</code></pre>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html">join</a>和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel-and-join.html">cancelAndJoin</a>都会等待所有的终结动作完成，所以上面的例子会产生以下输出</p>
<pre><code class="language-text">job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
job: I'm running finally
main: Now I can quit.
</code></pre>
<h2 id="运行不可取消的程序块">运行不可取消的程序块</h2>
<p>在前面例子中，任何试图在 <code>finally</code>块中使用suspend函数的行为都会导致<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a>，因为运行这段代码的coroutine被取消了。通常情况下这不是问题，因为所有表现良好的关闭操作（关闭File、取消Job或关闭任何类型的channel）通常都是无阻塞的，不涉及任何挂起函数。然而，在极少数情况下，当你需要在一个已取消的程序中暂停时，你可以使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html">withContext</a>函数和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-non-cancellable/index.html">NonCancellable</a> 的context 将相应的代码包裹在<code>withContext(NonCancellable) {...}</code>中，正如下面的例子所示。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch {
        try {
            repeat(1000) { i -&gt;
                println(&quot;job: I'm sleeping $i ...&quot;)
                delay(500L)
            }
        } finally {
            withContext(NonCancellable) {
                println(&quot;job: I'm running finally&quot;)
                delay(1000L)
                println(&quot;job: And I've just delayed for 1 sec because I'm non-cancellable&quot;)
            }
        }
    }
    delay(1300L) // delay a bit
    println(&quot;main: I'm tired of waiting!&quot;)
    job.cancelAndJoin() // cancels the job and waits for its completion
    println(&quot;main: Now I can quit.&quot;)
//sampleEnd    
}
</code></pre>
<p>代码运行结果</p>
<pre><code>job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
job: I'm running finally
job: And I've just delayed for 1 sec because I'm non-cancellable
main: Now I can quit.

</code></pre>
<h2 id="超时处理">超时处理</h2>
<p>取消执行一个coroutine的最明显且实际原因是因为它的执行时间已经超时了。虽然你可以手动跟踪相应的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>的引用，并在延迟一会儿后再启动一个单独的coroutine来取消那个job，这里推荐一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout</a>函数可以做到这点。请看下面的例子。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    withTimeout(1300L) {
        repeat(1000) { i -&gt;
            println(&quot;I'm sleeping $i ...&quot;)
            delay(500L)
        }
    }
//sampleEnd
}
</code></pre>
<p>输出结果如下:</p>
<pre><code class="language-text">I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
Exception in thread &quot;main&quot; kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms
</code></pre>
<p>由<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout</a>抛出的<code>TimeoutCancellationException</code>是<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a>的一个子类。我们以前没有看到它的堆栈跟踪印在控制台。这是因为在一个被取消的循环程序里面<code>CancellationException</code>被认为是循环程序完成的一个正常原因。然而，在这个例子中，我们在<code>main</code>函数中使用了`withTimeout'。</p>
<p>由于取消只是一个异常，所有的资源都以正常的方式关闭。如果你需要在任何一种超时情况下专门做一些额外的动作，你可以用<code>try {...} catch (e: TimeoutCancellationException) {...}</code>块来包装处理超时的代码，或者使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout-or-null.html">withTimeoutOrNull</a>函数，它与<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout</a>类似，但在超时后会返回<code>null</code>而不是抛出一个异常。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val result = withTimeoutOrNull(1300L) {
        repeat(1000) { i -&gt;
            println(&quot;I'm sleeping $i ...&quot;)
            delay(500L)
        }
        &quot;Done&quot; // will get cancelled before it produces this result
    }
    println(&quot;Result is $result&quot;)
//sampleEnd
}
</code></pre>
<p>输出结果如下:</p>
<pre><code class="language-text">I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
Result is null
</code></pre>
<h2 id="异步操作的超时和资源">异步操作的超时和资源</h2>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout</a>中的超时事件对于在其块中运行的代码来说是异步的，可能在任何时候发生，甚至在从超时代码块内部返回之前。如果你在区块内打开或获取一些需要在区块外关闭或释放的资源，请牢记这一点。</p>
<p>例如，这里我们用<code>Resource</code>类来模仿一个可关闭的资源，它只通过增加<code>acquired</code>计数器和从<code>close</code>函数中减去这个计数器来跟踪它被创建的次数。让我们用很小的超时来运行大量的循环程序，尝试在延迟一段时间后从<code>withTimeout</code>块内部获取这个资源，并从外部释放它。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

//sampleStart
var acquired = 0

class Resource {
    init { acquired++ } // Acquire the resource
    fun close() { acquired-- } // Release the resource
}

fun main() {
    runBlocking {
        repeat(100_000) { // Launch 100K coroutines
            launch { 
                val resource = withTimeout(60) { // Timeout of 60 ms
                    delay(50) // Delay for 50 ms
                    Resource() // Acquire a resource and return it from withTimeout block     
                }
                resource.close() // Release the resource
            }
        }
    }
    // Outside of runBlocking all coroutines have completed
    println(acquired) // Print the number of resources still acquired
}
//sampleEnd
</code></pre>
<p>如果你运行上面的代码，你会发现它并不总是打印0，尽管这可能取决于你的机器的时间，你可能需要在这个例子中调整超时时间，以真正看到非0值。</p>
<blockquote>
<p>注意，在这里从100K Coroutine中增加和减少<code>acquired</code>计数器是完全安全的，因为它总是发生在同一个主线程中。关于这一点，我们将在下一章的coroutine上下文中作进一步解释。</p>
</blockquote>
<p>为了解决这个问题，你可以在变量中存储对资源的引用，而不是从<code>withTimeout</code> 块中返回它</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

var acquired = 0

class Resource {
    init { acquired++ } // Acquire the resource
    fun close() { acquired-- } // Release the resource
}

fun main() {
//sampleStart
    runBlocking {
        repeat(100_000) { // Launch 100K coroutines
            launch { 
                var resource: Resource? = null // Not acquired yet
                try {
                    withTimeout(60) { // Timeout of 60 ms
                        delay(50) // Delay for 50 ms
                        resource = Resource() // Store a resource to the variable if acquired      
                    }
                    // We can do something else with the resource here
                } finally {  
                    resource?.close() // Release the resource if it was acquired
                }
            }
        }
    }
    // Outside of runBlocking all coroutines have completed
    println(acquired) // Print the number of resources still acquired
//sampleEnd
}
</code></pre>
<p>这个例子总是打印出零。资源不会泄漏。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Kotlin Coroutine Part 1. Basic]]></title>
        <id>https://waltcow.github.io/post/ Kotlin Coroutine Part 1. Basic/</id>
        <link href="https://waltcow.github.io/post/ Kotlin Coroutine Part 1. Basic/">
        </link>
        <updated>2021-07-22T06:56:28.000Z</updated>
        <summary type="html"><![CDATA[<p>kotlinx.coroutines 作为一个由Jetbrains开发的 Coroutine 管理库，它包含了很多高级的操作coroutines的API, 本文介绍一些基础用法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>kotlinx.coroutines 作为一个由Jetbrains开发的 Coroutine 管理库，它包含了很多高级的操作coroutines的API, 本文介绍一些基础用法。</p>
<!-- more -->
<h1 id="kotlin-coroutine">Kotlin Coroutine</h1>
<p>Kotlin 语言中 <em>async</em> 和 <em>await</em> 并不是保留的关键词， 它在标准库只提供了有限的low-level 的API，让其生态的库自己去管理Coroutine编程控制相关的细节。 另一方面，相对于其他语言中的Future和Promise，Kotlin提出了Suspend 的概念抽象让异步编程变得相对安全和更少出错。</p>
<p><em>kotlinx.coroutines</em> 作为一个由Jetbrains开发的 Coroutine 管理库，它包含了很多高级的操作coroutines的API，譬如 <em>launch</em> 和 <em>async</em> 还有其他。</p>
<p>接下来阐述coroutine的基本概念</p>
<p>Coroutine 是可suspend计算的实例, 概念上它和线程非常的相似，它们都会接收一段块状代码，并与剩下的代码同时执行</p>
<p>但值得注意的是，coroutine 是不和任何特定的线程绑定在一起的，它可能会在一条线程上执行的，而在另外一条上恢复。</p>
<p>Coroutines 可以被想象为轻量化的线程，但它们之间有着重要的区别，以至于在真实的使用场景中和线程有着明显的不同</p>
<p>下面代码作为首个coroutine的例子作为阐述</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

//sampleStart
fun main() = runBlocking { // this: CoroutineScope
    launch { // launch a new coroutine and continue
        delay(1000L) // non-blocking delay for 1 second (default time unit is ms)
        println(&quot;World!&quot;) // print after delay
    }
    println(&quot;Hello&quot;) // main coroutine continues while a previous one is delayed
}
//sampleEnd
</code></pre>
<p>打印的结果</p>
<pre><code>Hello
World!
</code></pre>
<p>下面逐行分析代码的执行过程</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a>  是 coroutine构造器. 它另开了新的协程，同时执行剩下的代码，这都是同时独立的执行，所以 <strong>Hello</strong> 会第一个被打印出来</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a>  是一个特殊 <em>suspending function</em>. 它会在coroutine上 <em>suspends</em> 一段时间。 coroutine在暂停的同时并不会对阻塞它所处在的线程 ，同时允许其他的coroutine 在它当前的线程中执行它们的代码。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a>  另一个 coroutine的构造器，它可以让协程的代码和外界有了桥接和联系，以main() 作为入口。在一系列的coroutine外面会被runBlocking 用 { … }   包着，在IDE 下面会有高亮的提示  ::CoroutineScope hint right after the runBlocking opening curly brace:: 当你在你代码中用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a> 发起了调用，却忘记用 runBlocking包裹时将会出现报错，因为 launch 只能在   <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> 中声明。</p>
<p><strong>runBlocking</strong> 意味着处在这一线程中的（上面例子为主线程）代码在执行的过程中将会被 <strong>blocked</strong>，直到runBlocking { … } 所有的coroutines 完成所有的执行。你会经常看到runBlocking 用在程序中非常靠前的位置，并且很少会在真实的业务代码中看到。这是因为线程是非常昂贵的资源，阻塞它们是很低效且并不是我们想要的结果。</p>
<p>结构化的并发编程</p>
<p>Coroutines 遵循着 <strong>结构化并发的</strong> 的原则，这意味着新的coroutines 只能被特定的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> 发起，它界定了coroutines的生命周期。</p>
<p>上面的例子介绍了 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a> 的使用，它创建了相关的作用域，因此前一个例子中一直等到 延迟一秒后 world 的输出 才结束。</p>
<p>在真实的应用中。我们可能启动多个协程。 结构化的同步确保了它们不会丢失和导致内存泄漏。外部的作用域会等到它内部的子协程结束才退出。</p>
<p>结构化的同步也确保了代码中的所有错误都能正确地被收集下来并不会丢失。</p>
<h3 id="提取函数并重构">提取函数并重构</h3>
<p>让我们把 launch{ ... } 中的代码块提取到一个单独的函数中。当你对这段代码进行 &quot;提取函数 &quot;重构时，你将声明一个带有suspend修改器的新函数。这是你的第一个suspend函数。suspend函数可以像普通函数一样在 coroutine 中使用，但它们的有着suspend特性，它们可以反过来使用其他suspend的函数（如本例中的 delay）来挂起 coroutine 的执行。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

//sampleStart
fun main() = runBlocking { // this: CoroutineScope
    launch { doWorld() }
    println(“Hello”)
}

// this is your first suspending function
suspend fun doWorld() {
    delay(1000L)
    println(“World!”)
}
//sampleEnd
</code></pre>
<h3 id="作用域的构造器">作用域的构造器</h3>
<p>除了自带中的不同构建器所提供scope之外，还可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a> 构建器来声明自定义的scope。它创建一个coroutine scope，在所有启动的子程序完成之后才会被销毁。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a> 和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a> 构建器看起来很相似，因为它们都在等待其主体和所有子程序完成。主要的区别在于 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a>方法会阻塞当前线程并进行等待，而<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>只是暂停，释放底层线程用于其他用途。因为这个区别，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a>是一个普通的函数，而<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>是一个暂停的函数。</p>
<p>你可以从任何一个suspend函数中使用coroutineScope。例如，你可以将Hello和World的并发打印转移到一个suspend的函数doWorld()中。</p>
<pre><code class="language-kotlin">
import kotlinx.coroutines.*

//sampleStart
fun main() = runBlocking {
    doWorld()
}

suspend fun doWorld() = coroutineScope {  // this: CoroutineScope
    launch {
        delay(1000L)
        println(“World!”)
    }
    println(“Hello”)
}
//sampleEnd
</code></pre>
<p>代码输出结果</p>
<pre><code>Hello
World!
</code></pre>
<h3 id="作用域构造器和并发">作用域构造器和并发</h3>
<p>一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>构建器可以用在任何suspend函数中，以执行多个并发的操作。让我们在一个doWorld 的suspend函数中启动两个并发的coroutine。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

//sampleStart
// Sequentially executes doWorld followed by “Done”
fun main() = runBlocking {
    doWorld()
    println(“Done”)
}

// Concurrently executes both sections
suspend fun doWorld() = coroutineScope { // this: CoroutineScope
    launch {
        delay(2000L)
        println(“World 2”)
    }
    launch {
        delay(1000L)
        println(“World 1”)
    }
    println(“Hello”)
}
//sampleEnd
</code></pre>
<p>launch { ... }块内的两段代码都是同时执行的，从开始的一秒钟后，先打印<em>World 1</em>，从开始的两秒钟后，接着打印 <em>World 2</em>。doWorld 中的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>只有在这两段代码完成后才会完成，所以doWorld返回并在这之后打印 <em>Done</em>。</p>
<h3 id="显式的job">显式的Job</h3>
<p>一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a> coroutine builder 会返回一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a> 对象，该对象是启动的 coroutine 的句柄，可以用来明确地等待其完成。例如，你可以等待子循环程序的完成，然后打印 <em>Done</em> 。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch { // launch a new coroutine and keep a reference to its Job
        delay(1000L)
        println(“World!”)
    }
    println(“Hello”)
    job.join() // wait until child coroutine completes
    println(“Done”) 
//sampleEnd    
}
</code></pre>
<p>代码输出结果</p>
<pre><code>Hello
World!
Done
</code></pre>
<h3 id="相当轻量化的coroutines">相当轻量化的Coroutines</h3>
<p>执行以下代码：</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

//sampleStart
fun main() = runBlocking {
    repeat(100_000) { // launch a lot of coroutines
        launch {
            delay(5000L)
            print(“.”)
        }
    }
}
//sampleEnd
</code></pre>
<p>它启动了100K个coroutines，5秒钟后，每个coroutine打印一个点。</p>
<p>现在，用线程试试（去掉<em>runBlocking</em>，用线程代替协程启动，用 <em>Thread.sleep</em>代替延迟）。会发生什么？(很可能你的代码会产生内存不足的错误)</p>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://kotlinlang.org/docs/coroutines-basics.html#your-first-coroutine">Coroutines basics</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://waltcow.github.io/post/about/</id>
        <link href="https://waltcow.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>一些coding的碎碎念</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>编程，电影，尝试写点东西</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p><a href="mailto:waltcow@gmail.com">Email</a></p>
<p><a href="https://github.com/waltcow">Github</a></p>
]]></content>
    </entry>
</feed>