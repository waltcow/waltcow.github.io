<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://waltcow.github.io</id>
    <title>waltcow</title>
    <updated>2021-07-29T03:23:32.833Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://waltcow.github.io"/>
    <link rel="self" href="https://waltcow.github.io/atom.xml"/>
    <subtitle>Do have faith in what you&apos;re doing.</subtitle>
    <logo>https://waltcow.github.io/images/avatar.png</logo>
    <icon>https://waltcow.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, waltcow</rights>
    <entry>
        <title type="html"><![CDATA[Kotlin Coroutine Part 4. Coroutine context and dispatchers]]></title>
        <id>https://waltcow.github.io/post/kotlin-coroutine-part-4-coroutine-context-and-dispatchers/</id>
        <link href="https://waltcow.github.io/post/kotlin-coroutine-part-4-coroutine-context-and-dispatchers/">
        </link>
        <updated>2021-07-29T03:20:50.000Z</updated>
        <summary type="html"><![CDATA[<p>这一节将介绍Coroutine 的上下文和调度器的使用</p>
]]></summary>
        <content type="html"><![CDATA[<p>这一节将介绍Coroutine 的上下文和调度器的使用</p>
<!-- more -->
<p>Coroutine总是在某些context中执行，这些context都是Kotlin标准库中定义的<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a>类型。</p>
<p>Coroutine 中的context 是一个多个变量集合。主要的变量是我们之前提到过的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>，以及它的<em>dispatcher</em>，这部分会在这节会提到。</p>
<h2 id="dispatchers和thread">Dispatchers和Thread</h2>
<p>Coroutine 的context包括一个<em>coroutine dispatcher</em>（见<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher</a>），它决定了对应的coroutine使用什么线程来执行。Coroutine dispatcher可以将coroutine的执行限制在一个特定的线程中，或将其分派调度到一个线程池中执行，或让它不受限制地运行。</p>
<p>所有coroutine的构建器如<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a>和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a>, 都接受一个可选的<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a>参数，可以用来指定新coroutine的 <em>dispatcher</em> 和context上的其他变量。</p>
<p>试试下面的例子</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    launch { // context of the parent, main runBlocking coroutine
        println(&quot;main runBlocking      : I'm working in thread ${Thread.currentThread().name}&quot;)
    }
    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread
        println(&quot;Unconfined            : I'm working in thread ${Thread.currentThread().name}&quot;)
    }
    launch(Dispatchers.Default) { // will get dispatched to DefaultDispatcher 
        println(&quot;Default               : I'm working in thread ${Thread.currentThread().name}&quot;)
    }
    launch(newSingleThreadContext(&quot;MyOwnThread&quot;)) { // will get its own new thread
        println(&quot;newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}&quot;)
    }
//sampleEnd    
}
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-text">Unconfined            : I'm working in thread main
Default               : I'm working in thread DefaultDispatcher-worker-1
newSingleThreadContext: I'm working in thread MyOwnThread
main runBlocking      : I'm working in thread main
</code></pre>
<p>当<code>launch { ... }</code> 以无参数的方式启动时，它继承了它调用者的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>的context（也就是调度器）。在上面的例子中，它继承了在 <code>main</code>线程中运行的 <code>runBlocking</code> 的context。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html">Dispatchers.Unconfined</a>是一个特殊的调度器，看起来也是在<code>main</code>线程中运行，但事实上，它是一种不同的机制，后面会解释。</p>
<p>当在作用域中没有明确指定其他调度器时，会使用默认的调度器。它由<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html">Dispatchers.Default</a>表示，并使用一个共享的后台线程池。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html">newSingleThreadContext</a>为coroutine创建一个线程来运行。一个专门的线程是一种非常昂贵的资源。在实际应用中，当线程不再需要时，必须使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-executor-coroutine-dispatcher/close.html">close</a>函数将其释放，或者将其存储在一个顶层变量中，在整个应用中重复使用。</p>
<h2 id="非封闭式和封闭式dispatchers">非封闭式和封闭式Dispatchers</h2>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html">Dispatchers.Unconfined</a>  dispatcher会在调用者线程中，当直到第一个暂停点才启动一个coroutine。</p>
<p>在暂停之后，该coroutine的恢复完全由被调用的暂停函数的线程所决定 。<em>Unconfined dispatcher</em> 适合于那种处在一个特定线程内执行既不消耗CPU，也不更新任何共享数据（如UI）的coroutines。</p>
<p>在另一边，<em>dispatcher</em> 默认从外部 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> 继承。譬如 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a> coroutine中默认的dispatcher将会被限制在调用者线程中。因此它的coroutine将限制在这个线程中并遵循FIFO调度</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread
        println(&quot;Unconfined      : I'm working in thread ${Thread.currentThread().name}&quot;)
        delay(500)
        println(&quot;Unconfined      : After delay in thread ${Thread.currentThread().name}&quot;)
    }
    launch { // context of the parent, main runBlocking coroutine
        println(&quot;main runBlocking: I'm working in thread ${Thread.currentThread().name}&quot;)
        delay(1000)
        println(&quot;main runBlocking: After delay in thread ${Thread.currentThread().name}&quot;)
    }
//sampleEnd    
}
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-text">Unconfined      : I'm working in thread main
main runBlocking: I'm working in thread main
Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor
main runBlocking: After delay in thread main
</code></pre>
<p>因此，从 <code>runBlocking {...}</code>继承的上下文的coroutine将继续在<code>main</code>线程中执行，而<em>Unconfined</em>的coroutine则在<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a>函数使用的默认执行器线程中恢复。</p>
<blockquote>
<p>Unconfined 调度器是一种先进的实现机制，在某些个别的情况下可能会很有用，在这些情况下，不需要为以后的cououtine指定dispatcher，或者产生不想要的side-effects, 因为coroutine中的一些操作必须立即执行。在一般的代码中不应该使用unconfined dispatcher。</p>
</blockquote>
<h2 id="调试-coroutines-和-threads">调试 Coroutines 和 Threads</h2>
<p>Coroutine可以在一个线程上暂停，在另一个线程上恢复。即使是同处一个Thread调度器，如果你没有特殊的工具，可能也很难弄清楚这个程序在做什么，在哪里做，什么时候做。</p>
<h3 id="用idea进行调试">用IDEA进行调试</h3>
<p>Kotlin插件的Coroutine调试器简化了在IntelliJ IDEA中调试coroutine的工作。</p>
<blockquote>
<p>调试器适用于1.3.8或更高版本的<code>kotlinx-coroutines-core</code></p>
</blockquote>
<p>在<strong>调试</strong>工具窗口中包含<strong>程序</strong>标签。在这个Tab中，你可以找到关于当前运行和暂停的程序的信息。这些程序按它们所运行的调度器进行分组。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/Kotlin/kotlinx.coroutines/master/docs/images/coroutine-debug-1.png" alt="Debugging coroutines" loading="lazy"></figure>
<p>使用coroutine调试器，你可以。</p>
<ul>
<li>检查每个coroutine的状态。</li>
<li>查看正在运行和暂停的coroutine的local变量和captured变量的值。</li>
<li>查看完整的coroutine创建栈，以及coroutine内部的调用栈。堆栈包括所有带有变量值的帧，甚至那些在标准调试过程中会丢失的帧。</li>
<li>获得一个完整的报告，其中包含每个程序的状态和它的堆栈。要获得它，在<strong>程序</strong>标签内点击右键，然后点击<strong>Get Coroutines Dump</strong>。</li>
</ul>
<p>要开始进行coroutine调试，你只需要设置断点并在调试模式下运行应用程序。</p>
<p>在 <a href="https://kotlinlang.org/docs/tutorials/coroutines/debug-coroutines-with-idea.html">教程</a>中了解更多关于coroutines调试的信息。</p>
<h3 id="使用日志进行调试">使用日志进行调试</h3>
<p>在没有Coroutine Debugger的情况下，调试应用程序的另一种方法是在每个日志语句中打印日志文件中的线程名称。这个功能被普遍日志框架支持。当使用coroutines时，单单是线程名称并不能提供太多的context 信息，为了使其更容易调试，<code>kotlinx.coroutines</code>包含了调试工具。</p>
<p>使用<code>-Dkotlinx.coroutines.debug</code>JVM选项运行以下代码。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun log(msg: String) = println(&quot;[${Thread.currentThread().name}] $msg&quot;)

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val a = async {
        log(&quot;I'm computing a piece of the answer&quot;)
        6
    }
    val b = async {
        log(&quot;I'm computing another piece of the answer&quot;)
        7
    }
    log(&quot;The answer is ${a.await() * b.await()}&quot;)
//sampleEnd    
}
</code></pre>
<p>上面包含三个coroutines程序。<code>runBlocking</code>中的主程序（#1）和两个计算延迟值<code>a</code>（#2）和<code>b</code>（#3）的程序。它们都是在<code>runBlocking</code>的context中执行的，并且被限制在<code>main</code>线程中。</p>
<p>这段代码的输出是</p>
<pre><code class="language-text">[main @coroutine#2] I'm computing a piece of the answer
[main @coroutine#3] I'm computing another piece of the answer
[main @coroutine#1] The answer is 42
</code></pre>
<p><code>log</code>函数在方括号中打印出线程的名称，你可以看到它是<code>main</code>线程，上面附加了当前执行的coroutine的标识。当调试模式开启时，这个标识符会分配给所有创建的coroutines。</p>
<blockquote>
<p>当JVM以<code>-ea</code>选项运行时，调试模式也被打开。你可以在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-d-e-b-u-g_-p-r-o-p-e-r-t-y_-n-a-m-e.html">DEBUG_PROPERTY_NAME</a> 阅读更多关于调试设施的信息</p>
</blockquote>
<h2 id="threads之间的跳转">Threads之间的跳转</h2>
<p>使用<code>-Dkotlinx.coroutines.debug</code>JVM选项运行以下代码（见<a href="#debugging-coroutines-and-threads">debug</a>）</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun log(msg: String) = println(&quot;[${Thread.currentThread().name}] $msg&quot;)

fun main() {
//sampleStart
    newSingleThreadContext(&quot;Ctx1&quot;).use { ctx1 -&gt;
        newSingleThreadContext(&quot;Ctx2&quot;).use { ctx2 -&gt;
            runBlocking(ctx1) {
                log(&quot;Started in ctx1&quot;)
                withContext(ctx2) {
                    log(&quot;Working in ctx2&quot;)
                }
                log(&quot;Back to ctx1&quot;)
            }
        }
    }
//sampleEnd    
}
</code></pre>
<p>上面演示了几种新特性。一个是使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a>明确指定的context，另一个是使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html">withContext</a>函数来改变一个coroutine的context，同时仍然保持在同一个coroutine中，你可以在下面的输出中看到。</p>
<pre><code class="language-text">[Ctx1 @coroutine#1] Started in ctx1
[Ctx2 @coroutine#1] Working in ctx2
[Ctx1 @coroutine#1] Back to ctx1
</code></pre>
<p>请注意，这个例子也使用了Kotlin标准库中的<code>use</code>函数，用来在不再需要时释放出创建出来的Thread [newSingleThreadContext]（https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html）创建的线程。</p>
<h2 id="context中的job">Context中的Job</h2>
<p>Coroutine的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>是其context的一部分，你可以使用<code>coroutineContext[Job]</code>表达式拿到。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    println(&quot;My job is ${coroutineContext[Job]}&quot;)
//sampleEnd    
}
</code></pre>
<p>在<a href="#debugging-coroutines-and-threads">调试模式</a>下，它的输出结果是这样的。</p>
<pre><code>My job is &quot;coroutine#1&quot;:BlockingCoroutine{Active}@6d311334
</code></pre>
<p>注意，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>中的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html">isActive</a>只是<code>coroutineContext[Job]?.isActive == true</code>的shortcut而已。</p>
<h2 id="coroutine的层级结构">Coroutine的层级结构</h2>
<p>当一个coroutine在另一个coroutine的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>中启动时，它通过<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/coroutine-context.html">CoroutineScope.coroutineContext</a>继承其context，新建的coroutine中的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>成为父级coroutine的Job的child。当父级coroutine被取消时，它下面所有child coroutine也会被递归地取消。</p>
<p>然而，这种父子关系可以通过以下两种方式之一显式声明推翻。</p>
<ol>
<li>当启动一个cououtine时明确指定了一个不同的context（例如，<code>GlobalScope.launch</code>），那么它就不会从父级context继承<code>Job</code>。</li>
<li>当一个不同的<code>Job</code>对象被传递作为新的coroutine的context时（如下面的例子所示），那么它将覆盖父级context中的<code>Job</code>。</li>
</ol>
<p>在这两种情况下，启动的coroutine都是独立运行，不与它所启动的context相联系。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    // launch a coroutine to process some kind of incoming request
    val request = launch {
        // it spawns two other jobs
        launch(Job()) { 
            println(&quot;job1: I run in my own Job and execute independently!&quot;)
            delay(1000)
            println(&quot;job1: I am not affected by cancellation of the request&quot;)
        }
        // and the other inherits the parent context
        launch {
            delay(100)
            println(&quot;job2: I am a child of the request coroutine&quot;)
            delay(1000)
            println(&quot;job2: I will not execute this line if my parent request is cancelled&quot;)
        }
    }
    delay(500)
    request.cancel() // cancel processing of the request
    delay(1000) // delay a second to see what happens
    println(&quot;main: Who has survived request cancellation?&quot;)
//sampleEnd
}
</code></pre>
<p>这段代码的输出是：</p>
<pre><code class="language-text">job1: I run in my own Job and execute independently!
job2: I am a child of the request coroutine
job1: I am not affected by cancellation of the request
main: Who has survived request cancellation?
</code></pre>
<h2 id="父级coroutine的职责">父级Coroutine的职责</h2>
<p>父级coroutine总是等待其所有子级coroutine的执行完成。父级coroutine不必关心它下面子程序的启动，也不必使用子程序们的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html">Job.join</a>来等待它们结束。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    // launch a coroutine to process some kind of incoming request
    val request = launch {
        repeat(3) { i -&gt; // launch a few children jobs
            launch  {
                delay((i + 1) * 200L) // variable delay 200ms, 400ms, 600ms
                println(&quot;Coroutine $i is done&quot;)
            }
        }
        println(&quot;request: I'm done and I don't explicitly join my children that are still active&quot;)
    }
    request.join() // wait for completion of the request, including all its children
    println(&quot;Now processing of the request is complete&quot;)
//sampleEnd
}
</code></pre>
<p>这段代码的输出是：</p>
<pre><code class="language-text">request: I'm done and I don't explicitly join my children that are still active
Coroutine 0 is done
Coroutine 1 is done
Coroutine 2 is done
Now processing of the request is complete
</code></pre>
<h2 id="为调试中的coroutines-命名">为调试中的coroutines 命名</h2>
<p>当你使用coroutine时打印日志，为coroutine分配不同id有助于把相同coroutine的日志记录关联起来。然而，当一个coroutine与处理一个特定的请求或做一些后台任务 联系在一起时，为了调试的目的，最好先显式地命名它。在context 中的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-name/index.html">CoroutineName</a> 作用与线程名相同。当<a href="#debugging-coroutines-and-threads">debugging mode</a>开启时，它被包含在执行这个coroutine的线程名称中。</p>
<p>下面的例子演示下这个概念。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun log(msg: String) = println(&quot;[${Thread.currentThread().name}] $msg&quot;)

fun main() = runBlocking(CoroutineName(&quot;main&quot;)) {
//sampleStart
    log(&quot;Started main coroutine&quot;)
    // run two background value computations
    val v1 = async(CoroutineName(&quot;v1coroutine&quot;)) {
        delay(500)
        log(&quot;Computing v1&quot;)
        252
    }
    val v2 = async(CoroutineName(&quot;v2coroutine&quot;)) {
        delay(1000)
        log(&quot;Computing v2&quot;)
        6
    }
    log(&quot;The answer for v1 / v2 = ${v1.await() / v2.await()}&quot;)
//sampleEnd    
}
</code></pre>
<p>使用<code>-Dkotlinx.coroutines.debug</code>JVM选项，它产生下面的输出。</p>
<pre><code class="language-text">[main @main#1] Started main coroutine
[main @v1coroutine#2] Computing v1
[main @v2coroutine#3] Computing v2
[main @main#1] The answer for v1 / v2 = 42
</code></pre>
<h2 id="结合context的变量">结合context的变量</h2>
<p>有时我们需要在coroutine中的context定义多个变量。我们可以使用<code>+</code>操作符来实现这一点。例如，我们可以同时显式指定调度器和coroutine的名字后再启动coroutine。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    launch(Dispatchers.Default + CoroutineName(&quot;test&quot;)) {
        println(&quot;I'm working in thread ${Thread.currentThread().name}&quot;)
    }
//sampleEnd    
}
</code></pre>
<p>使用<code>-Dkotlinx.coroutines.debug</code>JVM选项，它产生下面的输出。</p>
<pre><code class="language-text">I'm working in thread DefaultDispatcher-worker-1 @test#2
</code></pre>
<h2 id="coroutine-作用域">Coroutine 作用域</h2>
<p>让我们把关于contexts、子coroutine和job的几个概念放在一起讨论下。假设我们的应用程序有一个关于生命周期的对象，但这个对象并不是一个coroutine。例如，我们正在编写一个Android应用程序，并在一个Android Activity的context中启动多个coroutine来执行异步操作来获取更新数据，做动画特效，等等。当Activity被销毁时，所有这些coroutine都必须被取消，以避免内存泄漏。当然，我们可以绑定Activity的生命周期，手动操作context和job来管理coroutine。在此之外 <code>kotlinx.coroutines</code>还提供了一个抽象的封装 -- <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>。你应该已经熟悉了 <em>CoroutineScope</em> ，因为所有的coroutine构建器都是它的扩展。</p>
<p>我们通过创建<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>的实例来管理我们coroutine的生命周期，该实例与Activity的生命周期相绑定。一个 <code>CoroutineScope</code> 实例可以由<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html">CoroutineScope()</a>或<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html">MainScope()</a> 创建。前者创建了一个通用的context，而后者为UI应用程序创建了一个作用域，并使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html">Dispatchers.Main</a>作为默认的dispatcher。</p>
<pre><code class="language-kotlin">class Activity {
    private val mainScope = MainScope()
    
    fun destroy() {
        mainScope.cancel()
    }
    // to be continued ...
</code></pre>
<p>现在，我们在这个 &quot;Activity &quot;的范围内，可以通过 <code>scope</code>来启动coroutines。在这个demo中，我们启动了十个延迟不同时间的coroutines。</p>
<pre><code class="language-kotlin">    // class Activity continues
    fun doSomething() {
        // launch ten coroutines for a demo, each working for a different time
        repeat(10) { i -&gt;
            mainScope.launch {
                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc
                println(&quot;Coroutine $i is done&quot;)
            }
        }
    }
} // class Activity ends
</code></pre>
<p>在我们的main函数中，我们创建了Activity，调用了 <code>doSomething</code>函数，并在500ms后销毁Activity。这就取消了所有从<code>doSomething</code>启动的coroutines。我们会发现，在Activity销毁后，即使我们再等一会儿，也不会有更多的消息被打印出来。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

class Activity {
    private val mainScope = CoroutineScope(Dispatchers.Default) // use Default for test purposes
    
    fun destroy() {
        mainScope.cancel()
    }

    fun doSomething() {
        // launch ten coroutines for a demo, each working for a different time
        repeat(10) { i -&gt;
            mainScope.launch {
                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc
                println(&quot;Coroutine $i is done&quot;)
            }
        }
    }
} // class Activity ends

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val activity = Activity()
    activity.doSomething() // run test function
    println(&quot;Launched coroutines&quot;)
    delay(500L) // delay for half a second
    println(&quot;Destroying activity!&quot;)
    activity.destroy() // cancels all coroutines
    delay(1000) // visually confirm that they don't work
//sampleEnd    
}
</code></pre>
<p>这段代码的输出是</p>
<pre><code class="language-text">Launched coroutines
Coroutine 0 is done
Coroutine 1 is done
Destroying activity!
</code></pre>
<p>正如你所看到的，只有前两个coroutines打印了一条消息，其他的都被<code>Activity.destroy()</code>中的一次<code>job.cancel()</code>调用取消了。</p>
<blockquote>
<p>注意，Android在所有entities的lifecycle中，都有对coroutine scope的优先支持。参见<a href="https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope">相应的文档</a>。</p>
</blockquote>
<h3 id="thread局部数据">Thread局部数据</h3>
<p>有时，如果可以将一些Thread本地的数据传递给coroutines或在coroutines之间传递，那么就很方便了。然而，由于coroutines没有被绑定到任何特定的Thread，如果手动处理绑定的话将相当十分笨拙。</p>
<p>针对 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html">ThreadLocal</a>，在这里我们可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/as-context-element.html">asContextElement</a>扩展函数来实现。它创建一个额外的context，用来记录给定的<code>ThreadLocal</code>的值，并在每次coroutine切换context时恢复它。</p>
<p>看下面的演示:</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

val threadLocal = ThreadLocal&lt;String?&gt;() // declare thread-local variable

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    threadLocal.set(&quot;main&quot;)
    println(&quot;Pre-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'&quot;)
    val job = launch(Dispatchers.Default + threadLocal.asContextElement(value = &quot;launch&quot;)) {
        println(&quot;Launch start, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'&quot;)
        yield()
        println(&quot;After yield, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'&quot;)
    }
    job.join()
    println(&quot;Post-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'&quot;)
//sampleEnd    
}
</code></pre>
<p>在这个例子中，我们使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html">Dispatchers.Default</a>在后台线程池中启动了一个新的coroutine，因此它在与线程池不同的线程上工作，但它依然可以访问通过<code>threadLocal.asContextElement(value = &quot;launch&quot;)</code>定义的Thread局部变量的值，不管coroutine在哪个Thread上执行。</p>
<p>因此调试下输出是:</p>
<pre><code class="language-text">Pre-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'
Launch start, current thread: Thread[DefaultDispatcher-worker-1 @coroutine#2,5,main], thread local value: 'launch'
After yield, current thread: Thread[DefaultDispatcher-worker-2 @coroutine#2,5,main], thread local value: 'launch'
Post-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'
</code></pre>
<p>我们很容易忘记设置相应的context变量。如果运行coroutine程序的Thread不同，那么从coroutine访问的线程本地变量可能会有一个意外的值。为了避免这种情况，建议使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/ensure-present.html">ensurePresent</a>方法，并在不适当的调用中 <em>fail-fast</em> 。</p>
<p><code>ThreadLocal</code>具有优先的支持，可以任何<code>kotlinx.coroutines</code>提供的接口中使用。但它有一个重要的限制：当thread-local被改变时，新的值不会传播给coroutine调用者（因为context变量不能跟踪<code>ThreadLocal</code>对象的访问），更新的值会在下一次suspend时丢失。当然你可以使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html">withContext</a>来更新coroutine中thread-local的值，更多细节见<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/as-context-element.html">asContextElement</a>。</p>
<p>另外，一个值可以存储在一个可变的容器中，如<code>class Counter(var i: Int)</code>，它又被存储在线程局部变量中。然而，在这种情况下，你要对这个变量会被进行潜在的并发修改进行管理。</p>
<p>对于高级用法，例如与日志MDC、context事务性，或任何其他内部使用thread-locals传递数据的库，请参阅对应实现的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-thread-context-element/index.html">ThreadContextElement</a>接口的文档。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin Coroutine Part 3. Composing suspending functions]]></title>
        <id>https://waltcow.github.io/post/kotlin-coroutine-part-3-composing-suspending-functions/</id>
        <link href="https://waltcow.github.io/post/kotlin-coroutine-part-3-composing-suspending-functions/">
        </link>
        <updated>2021-07-27T09:42:50.000Z</updated>
        <summary type="html"><![CDATA[<p>这一节将介绍各种构建suspend函数的方法</p>
]]></summary>
        <content type="html"><![CDATA[<p>这一节将介绍各种构建suspend函数的方法</p>
<!-- more -->
<h2 id="默认的串行执行">默认的串行执行</h2>
<p>假设我们预先定义了两个suspend函数，它们运行着一些比如远程服务调用或计算的逻辑。我们只是假装它们是有用的，在这个例子中，每个函数只是延迟一秒钟作为模拟。</p>
<pre><code class="language-kotlin">suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}
</code></pre>
<p>如果我们需要它们依次被调用 -- 首先是<code>doSomethingUsefulOne</code>，然后是<code>doSomethingUsefulTwo</code>，并计算它们的结果之和，我们该怎么做？在真实场景中，如果我们用第一个函数的返回结果来决定第二个函数是否需要调用或如何调用，我们就会这样做。</p>
<p>我们按正常的顺序调用，因为coroutine中的代码，就像普通代码一样，默认是顺序执行的。下面的例子通过测量两个suspend函数的总执行时间作为演示。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val time = measureTimeMillis {
        val one = doSomethingUsefulOne()
        val two = doSomethingUsefulTwo()
        println(&quot;The answer is ${one + two}&quot;)
    }
    println(&quot;Completed in $time ms&quot;)
//sampleEnd    
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}
</code></pre>
<p>运行的输出如下：</p>
<pre><code class="language-text">The answer is 42
Completed in 2017 ms
</code></pre>
<h2 id="使用async进行并发">使用async进行并发</h2>
<p>如果<code>doSomethingUsefulOne</code>和<code>doSomethingUsefulTwo</code>的调用之间没有依赖关系，而我们想同时进行这两个操作来更快地得到答案，怎么办？这就是<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a>发挥作用的地方。</p>
<p>从概念上讲，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a>就像<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a>一样。它启动了一个单独的coroutine，这是一个轻量级的线程，与所有其他的coroutine同时工作。不同的是，<code>launch</code>返回一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>，并且不携带任何结果值，而<code>async</code>返回一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/index.html">Deferred</a>--一个轻量级的非阻塞Future，代表一个Promise，以后提供一个结果。你可以在一个Deferred上使用<code>.await()</code>来获得它的最终结果，但是<code>Deferred</code>也是一个<code>Job</code>，所以你可以在需要时取消它。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val time = measureTimeMillis {
        val one = async { doSomethingUsefulOne() }
        val two = async { doSomethingUsefulTwo() }
        println(&quot;The answer is ${one.await() + two.await()}&quot;)
    }
    println(&quot;Completed in $time ms&quot;)
//sampleEnd    
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}

</code></pre>
<p>运行的输出如下：</p>
<pre><code class="language-text">The answer is 42
Completed in 1017 ms
</code></pre>
<p>这是两倍的速度，因为这两个coroutines是同时执行的。请注意，coroutines的并发性总是显式的。</p>
<h2 id="async的懒启动">async的懒启动</h2>
<p>另外，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a>可以通过将其<code>start</code>参数设置为<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y/index.html">CoroutineStart.LAZY</a>而变成懒启动。在这种模式下，只有当<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html">await</a>需要它的结果时，或者它的<code>Job</code>的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html">start</a>函数被调用时，它才会启动coroutine。运行下面的例子。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val time = measureTimeMillis {
        val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }
        val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }
        // some computation
        one.start() // start the first one
        two.start() // start the second one
        println(&quot;The answer is ${one.await() + two.await()}&quot;)
    }
    println(&quot;Completed in $time ms&quot;)
//sampleEnd    
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}
</code></pre>
<p>运行的输出如下：</p>
<pre><code class="language-text">The answer is 42
Completed in 1017 ms
</code></pre>
<p>这里定义了两个coroutines，但没有像前面的例子那样执行，而是通过调用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html">start</a>，将具体何时开始执行的控制权交给程序员。我们首先启动 &quot;one&quot;，然后启动 &quot;two&quot;，然后等待各个coroutines的完成。</p>
<p>请注意，如果我们只是在<code>println</code>中调用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html">await</a>，而不先在单个coroutine上调用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html">start</a>，这将导致顺序执行的，因为<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html">await</a>启动coroutine执行并等待其结束，这不是懒启动的预期行为。<code>async(start = CoroutineStart.LAZY)</code>的用例是在计算值涉及暂停功能的情况下替代标准<code>lazy</code>函数。</p>
<h2 id="async风格的函数">async风格的函数</h2>
<p>我们可以定义异步风格的函数，使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> 作为coroutine构建器来异步调用<code>doSomethingUsefulOne</code>和<code>doSomethingUsefulTwo</code>，配合<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html">GlobalScope</a>的引用来选择退出结构化并发。我们一般会用&quot;......Async &quot;作为后缀来命名这类函数，以强调它们使用异步方式执行，人们需要使用它返回的延迟值来获取结果。</p>
<blockquote>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html">GlobalScope</a>是一个精致的API，将在下面解释，你必须显式地选择使用<code>GlobalScope</code>与<code>@OptIn(DelicateCoroutinesApi::class)</code></p>
</blockquote>
<pre><code class="language-kotlin">// The result type of somethingUsefulOneAsync is Deferred&lt;Int&gt;
@OptIn(DelicateCoroutinesApi::class)
fun somethingUsefulOneAsync() = GlobalScope.async {
    doSomethingUsefulOne()
}

// The result type of somethingUsefulTwoAsync is Deferred&lt;Int&gt;
@OptIn(DelicateCoroutinesApi::class)
fun somethingUsefulTwoAsync() = GlobalScope.async {
    doSomethingUsefulTwo()
}
</code></pre>
<p>请注意，这些<code>xxxAsync</code>函数不是<em>suspending</em>函数。它们可以从任何地方使用。然而，使用它们意味着是异步<em>并发</em> 执行。</p>
<p>下面的例子介绍它们如何在coroutine之外的使用。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlin.system.*

//sampleStart
// note that we don't have `runBlocking` to the right of `main` in this example
fun main() {
    val time = measureTimeMillis {
        // we can initiate async actions outside of a coroutine
        val one = somethingUsefulOneAsync()
        val two = somethingUsefulTwoAsync()
        // but waiting for a result must involve either suspending or blocking.
        // here we use `runBlocking { ... }` to block the main thread while waiting for the result
        runBlocking {
            println(&quot;The answer is ${one.await() + two.await()}&quot;)
        }
    }
    println(&quot;Completed in $time ms&quot;)
}
//sampleEnd

@OptIn(DelicateCoroutinesApi::class)
fun somethingUsefulOneAsync() = GlobalScope.async {
    doSomethingUsefulOne()
}

@OptIn(DelicateCoroutinesApi::class)
fun somethingUsefulTwoAsync() = GlobalScope.async {
    doSomethingUsefulTwo()
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>The answer is 42
Completed in 1175 ms
</code></pre>
<blockquote>
<p>这种异步函数的编程风格在这里提出只是为了说明问题，因为它在其他编程语言中是一种比较流行的风格。但在Kotlin coroutines中使用这种风格是<strong>强烈反对</strong>的，原因如下</p>
</blockquote>
<p>设想一下，如果在<code>val one = somethingUsefulOneAsync()</code> 和 <code>one.await()</code>表达式之间，代码中出现了一些逻辑错误，程序抛出了一个异常，程序正在进行的操作就会中止。通常情况下，程序的全局错误处理会捕获这个异常，并报告这个错误，但程序可以继续进行其他操作。然而，在这里我们看到<code>somethingUsefulOneAsync</code>仍然在后台运行，尽管启动它的操作被中止了。这个问题在结构化并发中不会发生，如下节所示。</p>
<h2 id="使用async进行-结构化并发">使用async进行 结构化并发</h2>
<p>让我们以<a href="#concurrent-using-async">Concurrent using async</a>为例，提取一个函数来并发执行<code>doSomethingUsefulOne</code>和<code>doSomethingUsefulTwo</code>并返回其结果的总和。因为<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> coroutine builder是CoroutineScope](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html)的扩展，我们可以在作用域中使用它。</p>
<pre><code class="language-kotlin">suspend fun concurrentSum(): Int = coroutineScope {
    val one = async { doSomethingUsefulOne() }
    val two = async { doSomethingUsefulTwo() }
    one.await() + two.await()
}
</code></pre>
<p>这样，如果 <code>concurrentSum</code>函数的代码出了问题，它抛出了一个异常，所有在其范围内启动的程序都会被取消。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val time = measureTimeMillis {
        println(&quot;The answer is ${concurrentSum()}&quot;)
    }
    println(&quot;Completed in $time ms&quot;)
//sampleEnd    
}

suspend fun concurrentSum(): Int = coroutineScope {
    val one = async { doSomethingUsefulOne() }
    val two = async { doSomethingUsefulTwo() }
    one.await() + two.await()
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}
</code></pre>
<p>从上述 <code>main</code>函数的输出中可以看出，两个操作依然是并发执行。</p>
<pre><code class="language-text">The answer is 42
Completed in 1017 ms
</code></pre>
<p>取消总是通过coroutines的按层次传播的。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
    try {
        failedConcurrentSum()
    } catch(e: ArithmeticException) {
        println(&quot;Computation failed with ArithmeticException&quot;)
    }
}

suspend fun failedConcurrentSum(): Int = coroutineScope {
    val one = async&lt;Int&gt; { 
        try {
            delay(Long.MAX_VALUE) // Emulates very long computation
            42
        } finally {
            println(&quot;First child was cancelled&quot;)
        }
    }
    val two = async&lt;Int&gt; { 
        println(&quot;Second child throws an exception&quot;)
        throw ArithmeticException()
    }
    one.await() + two.await()
}

</code></pre>
<p>请注意第一个<code>async</code> 和等待中的父类是如何被<code>two</code>失败而被取消的。</p>
<pre><code class="language-text">Second child throws an exception
First child was cancelled
Computation failed with ArithmeticException
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin Coroutine Part 2. Cancellation and timeouts]]></title>
        <id>https://waltcow.github.io/post/kotlin-coroutine-part-2-cancellation-and-timeouts/</id>
        <link href="https://waltcow.github.io/post/kotlin-coroutine-part-2-cancellation-and-timeouts/">
        </link>
        <updated>2021-07-27T08:32:32.000Z</updated>
        <summary type="html"><![CDATA[<p>本文简单介绍一下 Kotlin Coroutine的取消和超时处理</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文简单介绍一下 Kotlin Coroutine的取消和超时处理</p>
<!-- more -->
<h1 id="kotlin-coroutine-part-2-cancellation-and-timeouts">Kotlin Coroutine Part 2. Cancellation and timeouts</h1>
<p>在一个长时间运行的应用程序中，你可能需要对运行在后台的coroutines进行细粒度的控制。例如，用户可能已经关闭了一个正在运行着的coroutine页面，现在不再需要其结果了，可以取消其操作。<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a>函数返回一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>，可以用来取消运行中的coroutine。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch {
        repeat(1000) { i -&gt;
            println(&quot;job: I'm sleeping $i ...&quot;)
            delay(500L)
        }
    }
    delay(1300L) // delay a bit
    println(&quot;main: I'm tired of waiting!&quot;)
    job.cancel() // cancels the job
    job.join() // waits for job's completion 
    println(&quot;main: Now I can quit.&quot;)
//sampleEnd    
}
</code></pre>
<p>它的输出结果如下</p>
<pre><code class="language-text">job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
main: Now I can quit.
</code></pre>
<p>只要main调用<code>job.cancel</code>，我们就看不到另一个coroutine的任何输出，因为它被取消了。还有一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>的扩展函数<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel-and-join.html">cancelAndJoin</a>，结合了<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel.html">cancel</a>和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html">join</a>的调用。</p>
<h2 id="取消是相互协同的">取消是相互协同的</h2>
<p>Coroutine的取消是<em>相互协同的</em>。Coroutine代码必须在相互协同下才能被取消。<code>kotlinx.coroutines</code>中所有的suspend函数都是<em>可取消的</em>。它们会检查Coroutine程序的取消，并在取消时抛出<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a>。然而，如果一个Coroutine在计算工作中，并且没有检查取消，那么它就不能被取消，就像下面的例子所示。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val startTime = System.currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (i &lt; 5) { // computation loop, just wastes CPU
            // print a message twice a second
            if (System.currentTimeMillis() &gt;= nextPrintTime) {
                println(&quot;job: I'm sleeping ${i++} ...&quot;)
                nextPrintTime += 500L
            }
        }
    }
    delay(1300L) // delay a bit
    println(&quot;main: I'm tired of waiting!&quot;)
    job.cancelAndJoin() // cancels the job and waits for its completion
    println(&quot;main: Now I can quit.&quot;)
//sampleEnd    
}

</code></pre>
<p>运行结果如下：</p>
<pre><code>job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
job: I'm sleeping 3 ...
job: I'm sleeping 4 ...
main: Now I can quit.

</code></pre>
<p>运行上面程序可以看到，即使在job被取消后，仍然继续打印 &quot;I'm sleeping&quot;，直到 job在反复执行5次后才完成。</p>
<h2 id="让正在运行中代码可以取消">让正在运行中代码可以取消</h2>
<p>有两种方法可以取消正在运行代码。第一种是周期性地调用一个检查取消的suspend函数。譬如使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html">yield</a>函数是个选择。另一种是显式地检查取消的状态。让我们试试后一种方法。</p>
<p>用<code>while (isActive)</code>替换前面例子中的<code>while (i &lt; 5)</code>，然后重新运行它。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val startTime = System.currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (isActive) { // cancellable computation loop
            // print a message twice a second
            if (System.currentTimeMillis() &gt;= nextPrintTime) {
                println(&quot;job: I'm sleeping ${i++} ...&quot;)
                nextPrintTime += 500L
            }
        }
    }
    delay(1300L) // delay a bit
    println(&quot;main: I'm tired of waiting!&quot;)
    job.cancelAndJoin() // cancels the job and waits for its completion
    println(&quot;main: Now I can quit.&quot;)
//sampleEnd    
}
</code></pre>
<p>运行结果：</p>
<pre><code>job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
main: Now I can quit.
</code></pre>
<p>正如你所看到的，现在这个循环被取消了。<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html">isActive</a>是通过<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>对象在coroutine内部可用的一个扩展属性。</p>
<h2 id="用-finally关闭占用资源">用 <code>finally</code>关闭占用资源</h2>
<p>可取消的暂停函数在取消时抛出<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a>，可以用常规方式处理。例如，<code>try {...} finally {...}</code>表达式和使用Kotlin的<code>use</code>函数，在一个coroutine被取消时正常执行它们的最终处理动作。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch {
        try {
            repeat(1000) { i -&gt;
                println(&quot;job: I'm sleeping $i ...&quot;)
                delay(500L)
            }
        } finally {
            println(&quot;job: I'm running finally&quot;)
        }
    }
    delay(1300L) // delay a bit
    println(&quot;main: I'm tired of waiting!&quot;)
    job.cancelAndJoin() // cancels the job and waits for its completion
    println(&quot;main: Now I can quit.&quot;)
//sampleEnd    
}

</code></pre>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html">join</a>和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel-and-join.html">cancelAndJoin</a>都会等待所有的终结动作完成，所以上面的例子会产生以下输出</p>
<pre><code class="language-text">job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
job: I'm running finally
main: Now I can quit.
</code></pre>
<h2 id="运行不可取消的程序块">运行不可取消的程序块</h2>
<p>在前面例子中，当运行代码的coroutine被取消的情况下， 任何试图在 <code>finally</code>块中使用suspend函数的行为都会导致<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a>。通常情况下这并不影响，因为所有处理得当的关闭操作（关闭File读写、取消Job或关闭任何类型的channel）通常都是无阻塞的，不涉及任何suspend函数。然而，在极少数情况下，当你需要在一个已取消的程序中暂停时，你可以使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html">withContext</a>函数和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-non-cancellable/index.html">NonCancellable</a> 的context 将相应的代码包裹在<code>withContext(NonCancellable) {...}</code>中，正如下面的例子所示。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch {
        try {
            repeat(1000) { i -&gt;
                println(&quot;job: I'm sleeping $i ...&quot;)
                delay(500L)
            }
        } finally {
            withContext(NonCancellable) {
                println(&quot;job: I'm running finally&quot;)
                delay(1000L)
                println(&quot;job: And I've just delayed for 1 sec because I'm non-cancellable&quot;)
            }
        }
    }
    delay(1300L) // delay a bit
    println(&quot;main: I'm tired of waiting!&quot;)
    job.cancelAndJoin() // cancels the job and waits for its completion
    println(&quot;main: Now I can quit.&quot;)
//sampleEnd    
}
</code></pre>
<p>代码运行结果</p>
<pre><code>job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
job: I'm running finally
job: And I've just delayed for 1 sec because I'm non-cancellable
main: Now I can quit.

</code></pre>
<h2 id="超时处理">超时处理</h2>
<p>取消一个执行中的coroutine，最常见原因是因为它的执行时间已经超时了。虽然你可以手动拿到相应的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>的引用，并在延迟一会儿后再启动一个单独的coroutine来取消那个job，但这里推荐用一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout</a>函数处理。请看下面的例子。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    withTimeout(1300L) {
        repeat(1000) { i -&gt;
            println(&quot;I'm sleeping $i ...&quot;)
            delay(500L)
        }
    }
//sampleEnd
}
</code></pre>
<p>输出结果如下:</p>
<pre><code class="language-text">I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
Exception in thread &quot;main&quot; kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms
</code></pre>
<p>由<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout</a>抛出的<code>TimeoutCancellationException</code>是<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a>的一个子类。我们以前没有在控制台看到它的堆栈信息。这是因为在一个被取消的循环程序里面，<code>CancellationException</code>被认为是循环程序结束的一个合理原因。然而，在这个例子中，我们在<code>main</code>函数中使用了`withTimeout'。</p>
<p>由于取消只是一个异常，所有的资源都以正常的方式关闭。如果你需要在任何一种超时情况下专门做一些额外的动作，你可以用<code>try {...} catch (e: TimeoutCancellationException) {...}</code>块来包装处理超时的代码，或者使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout-or-null.html">withTimeoutOrNull</a>函数，它与<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout</a>类似，但不同是它会在超时后会返回<code>null</code>而不是抛出一个异常。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val result = withTimeoutOrNull(1300L) {
        repeat(1000) { i -&gt;
            println(&quot;I'm sleeping $i ...&quot;)
            delay(500L)
        }
        &quot;Done&quot; // will get cancelled before it produces this result
    }
    println(&quot;Result is $result&quot;)
//sampleEnd
}
</code></pre>
<p>输出结果如下:</p>
<pre><code class="language-text">I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
Result is null
</code></pre>
<h2 id="异步操作的超时处理和资源管理">异步操作的超时处理和资源管理</h2>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout</a>中的超时事件对于在其块中运行的代码来说是异步的，可能在任何时候发生，甚至在从超时代码块内部返回之前。如果你在区块内打开或获取一些需要在区块外关闭或释放的资源，请牢记这一点。</p>
<p>例如，这里我们用<code>Resource</code>类来模仿一个可关闭的资源，它只通过增加<code>acquired</code>计数器和从<code>close</code>函数中减去这个计数器来跟踪它被创建的次数。让我们用很小的超时来运行大量的循环程序，尝试在延迟一段时间后从<code>withTimeout</code>块内部获取这个资源，并从外部释放它。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

//sampleStart
var acquired = 0

class Resource {
    init { acquired++ } // Acquire the resource
    fun close() { acquired-- } // Release the resource
}

fun main() {
    runBlocking {
        repeat(100_000) { // Launch 100K coroutines
            launch { 
                val resource = withTimeout(60) { // Timeout of 60 ms
                    delay(50) // Delay for 50 ms
                    Resource() // Acquire a resource and return it from withTimeout block     
                }
                resource.close() // Release the resource
            }
        }
    }
    // Outside of runBlocking all coroutines have completed
    println(acquired) // Print the number of resources still acquired
}
//sampleEnd
</code></pre>
<p>如果你运行上面的代码，你会发现它并不总是打印0，尽管这可能取决于你的机器的时间，你可能需要在这个例子中调整超时时间，以真正看到非0值。</p>
<blockquote>
<p>注意，在这里从100K Coroutine中增加和减少<code>acquired</code>计数器是完全安全的，因为它总是发生在同一个主线程中。关于这一点，我们将在下一章的coroutine上下文中作进一步解释。</p>
</blockquote>
<p>为了解决这个问题，你可以在变量中存储对资源的引用，而不是从<code>withTimeout</code> 块中返回它</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

var acquired = 0

class Resource {
    init { acquired++ } // Acquire the resource
    fun close() { acquired-- } // Release the resource
}

fun main() {
//sampleStart
    runBlocking {
        repeat(100_000) { // Launch 100K coroutines
            launch { 
                var resource: Resource? = null // Not acquired yet
                try {
                    withTimeout(60) { // Timeout of 60 ms
                        delay(50) // Delay for 50 ms
                        resource = Resource() // Store a resource to the variable if acquired      
                    }
                    // We can do something else with the resource here
                } finally {  
                    resource?.close() // Release the resource if it was acquired
                }
            }
        }
    }
    // Outside of runBlocking all coroutines have completed
    println(acquired) // Print the number of resources still acquired
//sampleEnd
}
</code></pre>
<p>这个例子总是打印出零。资源不会泄漏。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Kotlin Coroutine Part 1. Basic]]></title>
        <id>https://waltcow.github.io/post/ Kotlin Coroutine Part 1. Basic/</id>
        <link href="https://waltcow.github.io/post/ Kotlin Coroutine Part 1. Basic/">
        </link>
        <updated>2021-07-22T06:56:28.000Z</updated>
        <summary type="html"><![CDATA[<p>kotlinx.coroutines 作为一个由Jetbrains开发的 Coroutine 管理库，它包含了很多高级的操作coroutines的API, 本文介绍一些基础用法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>kotlinx.coroutines 作为一个由Jetbrains开发的 Coroutine 管理库，它包含了很多高级的操作coroutines的API, 本文介绍一些基础用法。</p>
<!-- more -->
<h1 id="kotlin-coroutine">Kotlin Coroutine</h1>
<p>Kotlin 语言中 <em>async</em> 和 <em>await</em> 并不是保留的关键词， 它在标准库只提供了有限的low-level 的API，让其生态的库自己去管理Coroutine编程控制相关的细节。 另一方面，相对于其他语言中的Future和Promise，Kotlin提出了Suspend 的概念抽象让异步编程变得相对安全和更少出错。</p>
<p><em>kotlinx.coroutines</em> 作为一个由Jetbrains开发的 Coroutine 管理库，它包含了很多高级的操作coroutines的API，譬如 <em>launch</em> 和 <em>async</em> 还有其他。</p>
<p>接下来阐述coroutine的基本概念</p>
<p>Coroutine 是可suspend计算的实例, 概念上它和线程非常的相似，它们都会接收一段块状代码，并与剩下的代码同时执行</p>
<p>但值得注意的是，coroutine 是不和任何特定的线程绑定在一起的，它可能会在一条线程上执行的，而在另外一条上恢复。</p>
<p>Coroutines 可以被想象为轻量化的线程，但它们之间有着重要的区别，以至于在真实的使用场景中和线程有着明显的不同</p>
<p>下面代码作为首个coroutine的例子作为阐述</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

//sampleStart
fun main() = runBlocking { // this: CoroutineScope
    launch { // launch a new coroutine and continue
        delay(1000L) // non-blocking delay for 1 second (default time unit is ms)
        println(&quot;World!&quot;) // print after delay
    }
    println(&quot;Hello&quot;) // main coroutine continues while a previous one is delayed
}
//sampleEnd
</code></pre>
<p>打印的结果</p>
<pre><code>Hello
World!
</code></pre>
<p>下面逐行分析代码的执行过程</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a>  是 coroutine构造器. 它另开了新的协程，同时执行剩下的代码，这都是同时独立的执行，所以 <strong>Hello</strong> 会第一个被打印出来</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a>  是一个特殊 <em>suspending function</em>. 它会在coroutine上 <em>suspends</em> 一段时间。 coroutine在暂停的同时并不会对阻塞它所处在的线程 ，同时允许其他的coroutine 在它当前的线程中执行它们的代码。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a>  另一个 coroutine的构造器，它可以让协程的代码和外界有了桥接和联系，以main() 作为入口。在一系列的coroutine外面会被runBlocking 用 { … }   包着，在IDE 下面会有高亮的提示  ::CoroutineScope hint right after the runBlocking opening curly brace:: 当你在你代码中用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a> 发起了调用，却忘记用 runBlocking包裹时将会出现报错，因为 launch 只能在   <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> 中声明。</p>
<p><strong>runBlocking</strong> 意味着处在这一线程中的（上面例子为主线程）代码在执行的过程中将会被 <strong>blocked</strong>，直到runBlocking { … } 所有的coroutines 完成所有的执行。你会经常看到runBlocking 用在程序中非常靠前的位置，并且很少会在真实的业务代码中看到。这是因为线程是非常昂贵的资源，阻塞它们是很低效且并不是我们想要的结果。</p>
<p>结构化的并发编程</p>
<p>Coroutines 遵循着 <strong>结构化并发的</strong> 的原则，这意味着新的coroutines 只能被特定的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> 发起，它界定了coroutines的生命周期。</p>
<p>上面的例子介绍了 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a> 的使用，它创建了相关的作用域，因此前一个例子中一直等到 延迟一秒后 world 的输出 才结束。</p>
<p>在真实的应用中。我们可能启动多个协程。 结构化的同步确保了它们不会丢失和导致内存泄漏。外部的作用域会等到它内部的子协程结束才退出。</p>
<p>结构化的同步也确保了代码中的所有错误都能正确地被收集下来并不会丢失。</p>
<h3 id="提取函数并重构">提取函数并重构</h3>
<p>让我们把 launch{ ... } 中的代码块提取到一个单独的函数中。当你对这段代码进行 &quot;提取函数 &quot;重构时，你将声明一个带有suspend修改器的新函数。这是你的第一个suspend函数。suspend函数可以像普通函数一样在 coroutine 中使用，但它们的有着suspend特性，它们可以反过来使用其他suspend的函数（如本例中的 delay）来挂起 coroutine 的执行。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

//sampleStart
fun main() = runBlocking { // this: CoroutineScope
    launch { doWorld() }
    println(“Hello”)
}

// this is your first suspending function
suspend fun doWorld() {
    delay(1000L)
    println(“World!”)
}
//sampleEnd
</code></pre>
<h3 id="作用域的构造器">作用域的构造器</h3>
<p>除了自带中的不同构建器所提供scope之外，还可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a> 构建器来声明自定义的scope。它创建一个coroutine scope，在所有启动的子程序完成之后才会被销毁。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a> 和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a> 构建器看起来很相似，因为它们都在等待其主体和所有子程序完成。主要的区别在于 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a>方法会阻塞当前线程并进行等待，而<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>只是暂停，释放底层线程用于其他用途。因为这个区别，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a>是一个普通的函数，而<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>是一个暂停的函数。</p>
<p>你可以从任何一个suspend函数中使用coroutineScope。例如，你可以将Hello和World的并发打印转移到一个suspend的函数doWorld()中。</p>
<pre><code class="language-kotlin">
import kotlinx.coroutines.*

//sampleStart
fun main() = runBlocking {
    doWorld()
}

suspend fun doWorld() = coroutineScope {  // this: CoroutineScope
    launch {
        delay(1000L)
        println(“World!”)
    }
    println(“Hello”)
}
//sampleEnd
</code></pre>
<p>代码输出结果</p>
<pre><code>Hello
World!
</code></pre>
<h3 id="作用域构造器和并发">作用域构造器和并发</h3>
<p>一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>构建器可以用在任何suspend函数中，以执行多个并发的操作。让我们在一个doWorld 的suspend函数中启动两个并发的coroutine。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

//sampleStart
// Sequentially executes doWorld followed by “Done”
fun main() = runBlocking {
    doWorld()
    println(“Done”)
}

// Concurrently executes both sections
suspend fun doWorld() = coroutineScope { // this: CoroutineScope
    launch {
        delay(2000L)
        println(“World 2”)
    }
    launch {
        delay(1000L)
        println(“World 1”)
    }
    println(“Hello”)
}
//sampleEnd
</code></pre>
<p>launch { ... }块内的两段代码都是同时执行的，从开始的一秒钟后，先打印<em>World 1</em>，从开始的两秒钟后，接着打印 <em>World 2</em>。doWorld 中的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>只有在这两段代码完成后才会完成，所以doWorld返回并在这之后打印 <em>Done</em>。</p>
<h3 id="显式的job">显式的Job</h3>
<p>一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a> coroutine builder 会返回一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a> 对象，该对象是启动的 coroutine 的句柄，可以用来明确地等待其完成。例如，你可以等待子循环程序的完成，然后打印 <em>Done</em> 。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch { // launch a new coroutine and keep a reference to its Job
        delay(1000L)
        println(“World!”)
    }
    println(“Hello”)
    job.join() // wait until child coroutine completes
    println(“Done”) 
//sampleEnd    
}
</code></pre>
<p>代码输出结果</p>
<pre><code>Hello
World!
Done
</code></pre>
<h3 id="相当轻量化的coroutines">相当轻量化的Coroutines</h3>
<p>执行以下代码：</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

//sampleStart
fun main() = runBlocking {
    repeat(100_000) { // launch a lot of coroutines
        launch {
            delay(5000L)
            print(“.”)
        }
    }
}
//sampleEnd
</code></pre>
<p>它启动了100K个coroutines，5秒钟后，每个coroutine打印一个点。</p>
<p>现在，用线程试试（去掉<em>runBlocking</em>，用线程代替协程启动，用 <em>Thread.sleep</em>代替延迟）。会发生什么？(很可能你的代码会产生内存不足的错误)</p>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://kotlinlang.org/docs/coroutines-basics.html#your-first-coroutine">Coroutines basics</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://waltcow.github.io/post/about/</id>
        <link href="https://waltcow.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>一些coding的碎碎念</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>编程，电影，尝试写点东西</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p><a href="mailto:waltcow@gmail.com">Email</a></p>
<p><a href="https://github.com/waltcow">Github</a></p>
]]></content>
    </entry>
</feed>