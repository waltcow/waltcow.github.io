<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://waltcow.github.io</id>
    <title>waltcow</title>
    <updated>2021-07-30T08:11:11.745Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://waltcow.github.io"/>
    <link rel="self" href="https://waltcow.github.io/atom.xml"/>
    <subtitle>Do have faith in what you&apos;re doing.</subtitle>
    <logo>https://waltcow.github.io/images/avatar.png</logo>
    <icon>https://waltcow.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, waltcow</rights>
    <entry>
        <title type="html"><![CDATA[Kotlin Coroutine Part 6. Channels]]></title>
        <id>https://waltcow.github.io/post/kotlin-coroutine-part-6-channels/</id>
        <link href="https://waltcow.github.io/post/kotlin-coroutine-part-6-channels/">
        </link>
        <updated>2021-07-30T08:04:47.000Z</updated>
        <summary type="html"><![CDATA[<p>Deferred为coroutine之间传递一个单值提供了方法。<em>Channels</em>提供了一种传递stream的方法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Deferred为coroutine之间传递一个单值提供了方法。<em>Channels</em>提供了一种传递stream的方法。</p>
<!-- more -->
<h2 id="channel-基本概念">Channel 基本概念</h2>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/index.html">Channel</a>在概念上与 <code>BlockingQueue</code>非常相似。主要的区别是，它没有阻塞的 <code>put</code>操作，而是有个暂停<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/send.html">发送</a>，也没有阻塞的 <code>take</code>操作，而有暂停<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html">接收</a>。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.channels.*

fun main() = runBlocking {
//sampleStart
    val channel = Channel&lt;Int&gt;()
    launch {
        // this might be heavy CPU-consuming computation or async logic, we'll just send five squares
        for (x in 1..5) channel.send(x * x)
    }
    // here we print five received integers:
    repeat(5) { println(channel.receive()) }
    println(&quot;Done!&quot;)
//sampleEnd
}
</code></pre>
<p>代码输出是：</p>
<pre><code class="language-text">1
4
9
16
25
Done!
</code></pre>
<h2 id="channels的关闭和迭代">channels的关闭和迭代</h2>
<p>与queue不同，channel可以被关闭，以表明没有更多的元素会到来。在接收方，使用一个常规的<code>for</code>循环就能接收channel中的元素。</p>
<p>从概念上讲，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/close.html">close</a>就像向channel发送一个特殊的关闭token。一旦收到这个关闭的token，迭代就会停止，因此可以保证在关闭之前所有先前发送的元素都被收到。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.channels.*

fun main() = runBlocking {
//sampleStart
    val channel = Channel&lt;Int&gt;()
    launch {
        for (x in 1..5) channel.send(x * x)
        channel.close() // we're done sending
    }
    // here we print received values using `for` loop (until the channel is closed)
    for (y in channel) println(y)
    println(&quot;Done!&quot;)
//sampleEnd
}
</code></pre>
<h2 id="构建channel生产者">构建channel生产者</h2>
<p>用coroutine产生一个sequence的模式是很常见的。这是 <em>生产者-消费者</em> 模式的一部分，经常出现在并发代码中。你可以把这样的生产者抽象成一个以channel为参数的函数，但要和函数中必须返回结果的常识有所不同。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html">produce</a> 是一个方便生产者使用的coroutine构建器，还有一个扩展函数<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html">consumeEach</a>，可以取代消费者一方的<code>for</code>循环。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.channels.*

fun CoroutineScope.produceSquares(): ReceiveChannel&lt;Int&gt; = produce {
    for (x in 1..5) send(x * x)
}

fun main() = runBlocking {
//sampleStart
    val squares = produceSquares()
    squares.consumeEach { println(it) }
    println(&quot;Done!&quot;)
//sampleEnd
}
</code></pre>
<h2 id="pipelines">Pipelines</h2>
<p><em>pipeline</em>是一种模式，代表着某个coroutine正在产生可能是无限值的stream。</p>
<pre><code class="language-kotlin">fun CoroutineScope.produceNumbers() = produce&lt;Int&gt; {
    var x = 1
    while (true) send(x++) // infinite stream of integers starting from 1
}
</code></pre>
<p>而另一个或多个coroutine正在消耗该 <em>stream</em>，做一些处理后返回其他结果。在下面的例子中返回某个数字的平方数</p>
<pre><code class="language-kotlin">fun CoroutineScope.square(numbers: ReceiveChannel&lt;Int&gt;): ReceiveChannel&lt;Int&gt; = produce {
    for (x in numbers) send(x * x)
}
</code></pre>
<p>The main code starts and connects the whole pipeline:</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.channels.*

fun main() = runBlocking {
//sampleStart
    val numbers = produceNumbers() // produces integers from 1 and on
    val squares = square(numbers) // squares integers
    repeat(5) {
        println(squares.receive()) // print first five
    }
    println(&quot;Done!&quot;) // we are done
    coroutineContext.cancelChildren() // cancel children coroutines
//sampleEnd
}

fun CoroutineScope.produceNumbers() = produce&lt;Int&gt; {
    var x = 1
    while (true) send(x++) // infinite stream of integers starting from 1
}

fun CoroutineScope.square(numbers: ReceiveChannel&lt;Int&gt;): ReceiveChannel&lt;Int&gt; = produce {
    for (x in numbers) send(x * x)
}
</code></pre>
<blockquote>
<p>所有创建coroutines的函数都被定义为<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>的扩展，因此我们可以依靠[structured concurrency](file:/Users/waltcow/Codes/kotlinx.coroutines/docs/topics/composing-suspending-functions.md#structured concurrency-with-async)来确保我们的应用程序中不会全局的coroutine。</p>
</blockquote>
<h2 id="用pipeline处理prime-numbers">用pipeline处理prime numbers</h2>
<p>让我们用一个例子将pipelines发挥到极致，这个例子是用coroutines的pipeline生成素数。我们从一个无限大的数字sequence开始。</p>
<pre><code class="language-kotlin">fun CoroutineScope.numbersFrom(start: Int) = produce&lt;Int&gt; {
    var x = start
    while (true) send(x++) // infinite stream of integers from start
}
</code></pre>
<p>下面pipeline对输入的数字流进行过滤，过滤所有能被给定的素数整除的数字。</p>
<pre><code class="language-kotlin">fun CoroutineScope.filter(numbers: ReceiveChannel&lt;Int&gt;, prime: Int) = produce&lt;Int&gt; {
    for (x in numbers) if (x % prime != 0) send(x)
}
</code></pre>
<p>现在，我们通过从2开始的数字stream来建立pipeline，从当前pipeline中抽取一个素数，并为每一个找到的素数启动新的pipeline。</p>
<pre><code class="language-Plain-Text">numbersFrom(2) -&gt; filter(2) -&gt; filter(3) -&gt; filter(5) -&gt; filter(7) ... 
</code></pre>
<p>下面的例子打印了前十个素数，在main线程的context中运行整个pipeline。由于所有的coroutines都是在主<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a>程序的范围内启动的，所以我们不需要记录已经启动的coroutines列表。我们使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel-children.html">cancelChildren</a>扩展函数，在打印完前十个质数后，取消所有子coroutines。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.channels.*

fun main() = runBlocking {
//sampleStart
    var cur = numbersFrom(2)
    repeat(10) {
        val prime = cur.receive()
        println(prime)
        cur = filter(cur, prime)
    }
    coroutineContext.cancelChildren() // cancel all children to let main finish
//sampleEnd    
}

fun CoroutineScope.numbersFrom(start: Int) = produce&lt;Int&gt; {
    var x = start
    while (true) send(x++) // infinite stream of integers from start
}

fun CoroutineScope.filter(numbers: ReceiveChannel&lt;Int&gt;, prime: Int) = produce&lt;Int&gt; {
    for (x in numbers) if (x % prime != 0) send(x)
}
</code></pre>
<p>代码输出结果：</p>
<pre><code class="language-text">2
3
5
7
11
13
17
19
23
29
</code></pre>
<p>注意，你可以使用标准库中的<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/iterator.html"><code>iterator</code></a> coroutine builder来构建同样的pipeline。用<code>iterator</code>代替<code>produce</code>，用<code>yield</code>代替<code>send</code>，用<code>next</code>代替<code>receive</code>，用<code>Iterator</code>代替<code>ReceiveChannel</code>，并且去掉coroutine scope。你也将不需要<code>runBlocking</code>。然而，如上所示，使用channel的pipeline的好处是，如果你在<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html">Dispatchers.Default</a> context中运行，它实际上可以使用多个CPU核。</p>
<p>总之，这是一种极其不切实际的寻找素数的方法。在实践中，pipeline确实涉及一些其他的暂停调用（比如对远程服务的异步调用），pipeline不能使用<code>sequence</code>/<code>iterator</code>构建，因为它们不允许任意暂停，不像<code>produce</code>那样完全异步。</p>
<h2 id="fan-out">Fan-out</h2>
<p>多个coroutines可以从同一channel接收，在它们之间分配工作。让我们从一个定期产生整数（每秒10个数字）的生产者coroutine开始讲起。</p>
<pre><code class="language-kotlin">fun CoroutineScope.produceNumbers() = produce&lt;Int&gt; {
    var x = 1 // start from 1
    while (true) {
        send(x++) // produce next
        delay(100) // wait 0.1s
    }
}
</code></pre>
<p>然后我们有几个处理的coroutines。在这个例子中，他们只是打印他们的ID和接收数字。</p>
<pre><code class="language-kotlin">fun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel&lt;Int&gt;) = launch {
    for (msg in channel) {
        println(&quot;Processor #$id received $msg&quot;)
    }    
}
</code></pre>
<p>现在让我们启动五个处理器，让它们工作近一秒钟。看看会发生什么。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.channels.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val producer = produceNumbers()
    repeat(5) { launchProcessor(it, producer) }
    delay(950)
    producer.cancel() // cancel producer coroutine and thus kill them all
//sampleEnd
}

fun CoroutineScope.produceNumbers() = produce&lt;Int&gt; {
    var x = 1 // start from 1
    while (true) {
        send(x++) // produce next
        delay(100) // wait 0.1s
    }
}

fun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel&lt;Int&gt;) = launch {
    for (msg in channel) {
        println(&quot;Processor #$id received $msg&quot;)
    }    
}
</code></pre>
<p>输出结果将类似于下面这个，尽管接收每个特定整数的处理器ID可能不同。</p>
<pre><code class="language-text">Processor #2 received 1
Processor #4 received 2
Processor #0 received 3
Processor #1 received 4
Processor #3 received 5
Processor #2 received 6
Processor #4 received 7
Processor #0 received 8
Processor #1 received 9
Processor #3 received 10
</code></pre>
<p>请注意，取消一个生产者coroutine会关闭其channel，从而终止了处理coroutines所做的channel的迭代。另外注意，我们如何用<code>for</code>循环迭代channel，在<code>launchProcessor</code>代码中执行<code>fan-out</code>。与 <code>consumeEach</code>不同的是，这种 <code>for</code> 循环模式在多个coroutines中使用是非常安全的。如果其中一个处理的coroutine失败了，那么其他的coroutine仍然在处理通道，而通过<code>consumeEach</code>编写的处理器总是在其正常或异常完成时消耗（取消）所在的channel。</p>
<h2 id="fan-in">Fan-in</h2>
<p>多个coroutines可以向同一个通道发送。例如，让我们有一个字符串的channel，和一个suspend函数，它以指定的延迟反复向这个channel发送一个指定的字符串。</p>
<pre><code class="language-kotlin">suspend fun sendString(channel: SendChannel&lt;String&gt;, s: String, time: Long) {
    while (true) {
        delay(time)
        channel.send(s)
    }
}
</code></pre>
<p>现在，让我们看看如果我们启动几个发送字符串的coroutines（在这个例子中，我们在main线程的context中启动， 它们作为子coroutine）会发生什么。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.channels.*

fun main() = runBlocking {
//sampleStart
    val channel = Channel&lt;String&gt;()
    launch { sendString(channel, &quot;foo&quot;, 200L) }
    launch { sendString(channel, &quot;BAR!&quot;, 500L) }
    repeat(6) { // receive first six
        println(channel.receive())
    }
    coroutineContext.cancelChildren() // cancel all children to let main finish
//sampleEnd
}

suspend fun sendString(channel: SendChannel&lt;String&gt;, s: String, time: Long) {
    while (true) {
        delay(time)
        channel.send(s)
    }
}
</code></pre>
<p>输出结果是：</p>
<pre><code class="language-text">foo
foo
BAR!
foo
foo
BAR!
</code></pre>
<h2 id="带缓冲的-channels">带缓冲的 channels</h2>
<p>到目前为止所展示的channels没有缓冲区。无缓冲的channel在发送方和接收方相遇时传输元素（又称交会）。如果发送先被调用，那么它将被暂停，直到调用接收；如果接收先被调用，它将被暂停，直到调用发送。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel.html">Channel()</a>工厂函数和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html">produce</a>构建器都需要可选的<code>capacity</code>参数来指定<em>缓冲区大小</em>。缓冲区允许发送者在暂停之前发送多个元素，类似于有指定容量的<code>BlockingQueue</code>，当缓冲区满了就会阻塞。看一下下面代码的行为。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.channels.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val channel = Channel&lt;Int&gt;(4) // create buffered channel
    val sender = launch { // launch sender coroutine
        repeat(10) {
            println(&quot;Sending $it&quot;) // print before sending each element
            channel.send(it) // will suspend when buffer is full
        }
    }
    // don't receive anything... just wait....
    delay(1000)
    sender.cancel() // cancel sender coroutine
//sampleEnd    
}
</code></pre>
<p>缓冲channels容量为<em>4</em>，打印了<em>5</em>次 &quot;sending&quot;。</p>
<pre><code class="language-text">Sending 0
Sending 1
Sending 2
Sending 3
Sending 4
</code></pre>
<p>前四个元素被添加到缓冲区，当尝试发送第五个元素时，发送者会暂停。</p>
<h2 id="平等的channels">平等的Channels</h2>
<p>对channels的发送和接收操作是<em>公平</em> 的，它们服从多个coroutine调用的顺序。它们以先入先出的顺序提供服务，例如，第一个调用 <code>receive</code>&quot;的程序会得到该元素。在下面的例子中，有两个 <code>ping</code>和 <code>pong</code>的coroutines 正在从共享的  <code>table</code>  Channel 中接收 <code>ball</code>对象。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.channels.*

//sampleStart
data class Ball(var hits: Int)

fun main() = runBlocking {
    val table = Channel&lt;Ball&gt;() // a shared table
    launch { player(&quot;ping&quot;, table) }
    launch { player(&quot;pong&quot;, table) }
    table.send(Ball(0)) // serve the ball
    delay(1000) // delay 1 second
    coroutineContext.cancelChildren() // game over, cancel them
}

suspend fun player(name: String, table: Channel&lt;Ball&gt;) {
    for (ball in table) { // receive the ball in a loop
        ball.hits++
        println(&quot;$name $ball&quot;)
        delay(300) // wait a bit
        table.send(ball) // send the ball back
    }
}
//sampleEnd
</code></pre>
<p><code>ping</code> 程序首先被启动，所以它是第一个接收<em>Ball</em>的<code>coroutines</code>。尽管 <code>ping</code> 的coroutines在将球送回桌子后立即开始接收，但球还是被 <code>pong</code> coroutines接收了，因为它已经在等待它了。</p>
<pre><code class="language-text">ping Ball(hits=1)
pong Ball(hits=2)
ping Ball(hits=3)
pong Ball(hits=4)
</code></pre>
<p>请注意，由于正在使用的执行器的性质，有时channels可能产生看起来不公平。详见<a href="https://github.com/Kotlin/kotlinx.coroutines/issues/111">issue</a></p>
<h2 id="定时-channels">定时 channels</h2>
<p>Ticker通道是一个特殊的会合channel，从这个channel的最后一次消费开始，每隔一定的延迟就会产生<code>Unit</code>。虽然它看起来是无用的，但它是一个有用的构件，可以创建复杂的基于时间的produce pipelines和方便做窗口化和时间相关处理。Ticker通道可以在<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html">select</a>中使用，来执行 <code>on tick</code>动作。</p>
<p>要创建这样的通道，请使用工厂方法<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html">ticker</a>。为了表示不再需要其他元素，使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html">ReceiveChannel.cancel</a>方法。</p>
<p>现在让我们看看它在实践中是如何工作的。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.channels.*

fun main() = runBlocking&lt;Unit&gt; {
    val tickerChannel = ticker(delayMillis = 100, initialDelayMillis = 0) // create ticker channel
    var nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }
    println(&quot;Initial element is available immediately: $nextElement&quot;) // no initial delay

    nextElement = withTimeoutOrNull(50) { tickerChannel.receive() } // all subsequent elements have 100ms delay
    println(&quot;Next element is not ready in 50 ms: $nextElement&quot;)

    nextElement = withTimeoutOrNull(60) { tickerChannel.receive() }
    println(&quot;Next element is ready in 100 ms: $nextElement&quot;)

    // Emulate large consumption delays
    println(&quot;Consumer pauses for 150ms&quot;)
    delay(150)
    // Next element is available immediately
    nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }
    println(&quot;Next element is available immediately after large consumer delay: $nextElement&quot;)
    // Note that the pause between `receive` calls is taken into account and next element arrives faster
    nextElement = withTimeoutOrNull(60) { tickerChannel.receive() } 
    println(&quot;Next element is ready in 50ms after consumer pause in 150ms: $nextElement&quot;)

    tickerChannel.cancel() // indicate that no more elements are needed
}
</code></pre>
<p>代码输出结果：</p>
<pre><code class="language-text">Initial element is available immediately: kotlin.Unit
Next element is not ready in 50 ms: null
Next element is ready in 100 ms: kotlin.Unit
Consumer pauses for 150ms
Next element is available immediately after large consumer delay: kotlin.Unit
Next element is ready in 50ms after consumer pause in 150ms: kotlin.Unit
</code></pre>
<p>请注意，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html">ticker</a>知道消费者可能的暂停，默认情况下，如果发生暂停，会调整下一个生产元素的延迟，试图保持一个固定的生产的速度。</p>
<p>可以选择指定一个等于<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-ticker-mode/-f-i-x-e-d_-d-e-l-a-y/index.html">TickerMode.FIXED_DELAY</a>的<code>mode</code>参数，以保持元素之间的固定延迟。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin Coroutine Part 5. Asynchronous Flow]]></title>
        <id>https://waltcow.github.io/post/kotlin-coroutine-part-5-asynchronous-flow/</id>
        <link href="https://waltcow.github.io/post/kotlin-coroutine-part-5-asynchronous-flow/">
        </link>
        <updated>2021-07-30T04:27:12.000Z</updated>
        <summary type="html"><![CDATA[<p>一个suspend的函数异步返回只能是个单值，我们如何才能返回<br>
多个异步计算的值？这就是Kotlin Flows的由来。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一个suspend的函数异步返回只能是个单值，我们如何才能返回<br>
多个异步计算的值？这就是Kotlin Flows的由来。</p>
<!-- more -->
<h2 id="表示多个值">表示多个值</h2>
<p>在Kotlin中我们可以使用 <em>collections</em> 来表示多个值。<br>
例如，我们可以有一个 <code>simple</code> 函数，返回的<code>List</code>包含三个数字。<br>
然后用 <em>forEach</em> 将它们全部打印出来。</p>
<pre><code class="language-kotlin">fun simple(): List&lt;Int&gt; = listOf(1, 2, 3)
 
fun main() {
    simple().forEach { value -&gt; println(value) } 
}
</code></pre>
<p>代码输出结果</p>
<pre><code class="language-text">1
2
3
</code></pre>
<h3 id="序列">序列</h3>
<p>如果我们用一些消耗CPU的代码来计算这些数字<br>
(每次计算需要100ms)，那么我们可以用 <code>Sequence</code> 来表示这些数字。</p>
<pre><code class="language-kotlin">fun simple(): Sequence&lt;Int&gt; = sequence { // sequence builder
    for (i in 1..3) {
        Thread.sleep(100) // pretend we are computing it
        yield(i) // yield next value
    }
}

fun main() {
    simple().forEach { value -&gt; println(value) } 
}
</code></pre>
<p>代码输出相同的结果，每次输出间隔100ms.</p>
<pre><code>1
2
3
</code></pre>
<h3 id="suspending-函数">Suspending 函数</h3>
<p>然而，这种计算会阻塞正在运行代码所在的main线程。<br>
在异步代码计算时这些值时，我们可以在<code>simple</code>函数带上<code>suspend</code>修改器。<br>
这样它就可以在不阻塞的情况下完成，并将结果作为一个列表返回。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*                 
                           
//sampleStart
suspend fun simple(): List&lt;Int&gt; {
    delay(1000) // pretend we are doing something asynchronous here
    return listOf(1, 2, 3)
}

fun main() = runBlocking&lt;Unit&gt; {
    simple().forEach { value -&gt; println(value) } 
}
//sampleEnd
</code></pre>
<p>代码在1秒后输出结果</p>
<pre><code>1
2
3
</code></pre>
<h3 id="flows">Flows</h3>
<p>使用<code>List&lt;Int&gt;</code>作为result的类型，意味着我们只能一次性返回所有的值。我们可以使用一个[<code>Flow&lt;Int&gt;</code>][Flow]类型来表示这个值的流，就像我们使用<code>Sequence&lt;Int&gt;</code>类型来表示同步计算的值一样。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart               
fun simple(): Flow&lt;Int&gt; = flow { // flow builder
    for (i in 1..3) {
        delay(100) // pretend we are doing something useful here
        emit(i) // emit next value
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    // Launch a concurrent coroutine to check if the main thread is blocked
    launch {
        for (k in 1..3) {
            println(&quot;I'm not blocked $k&quot;)
            delay(100)
        }
    }
    // Collect the flow
    simple().collect { value -&gt; println(value) } 
}
//sampleEnd
</code></pre>
<p>这段代码在打印每个数字之前会等待100ms，而不会阻塞主线程, 这一点可以通过以下方式得到验证。<br>
通过在主线程中运行的一个单独的循环程序每隔100ms打印 <em>I'm not blocked</em> 来验证。</p>
<pre><code class="language-text">I'm not blocked 1
1
I'm not blocked 2
2
I'm not blocked 3
3
</code></pre>
<p>请注意以下与前面例子中的Flow的代码不同。</p>
<ul>
<li>Flow类型的构建函数被称为[flow][_flow]。</li>
<li>在<code>flow { ... }</code>构建器块可以暂停。</li>
<li><code>simple</code>函数不再有<code>suspend</code>修饰。</li>
<li>使用[emit][FlowCollector.emit]函数从flow中输出值。</li>
<li>使用[collect][collect]函数从flow中收集值。</li>
</ul>
<blockquote>
<p>我们可以在 <code>simple</code>的 <code>flow { ...}</code>中用 <code>Thread.sleep</code> 替换 <code>delay</code>，可以看到在这种情况下，主线程被阻塞了。</p>
</blockquote>
<h2 id="被动的flows">被动的Flows</h2>
<p>Flows 类似于 <em>sequences</em> 中的 <code>cold stream</code>  , [flow][_flow] 构建器内的代码不会<br>
运行，直到该Flow被收集。这在下面的例子中很清楚说明这点</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart      
fun simple(): Flow&lt;Int&gt; = flow { 
    println(&quot;Flow started&quot;)
    for (i in 1..3) {
        delay(100)
        emit(i)
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    println(&quot;Calling simple function...&quot;)
    val flow = simple()
    println(&quot;Calling collect...&quot;)
    flow.collect { value -&gt; println(value) } 
    println(&quot;Calling collect again...&quot;)
    flow.collect { value -&gt; println(value) } 
}
//sampleEnd
</code></pre>
<p>输出如下</p>
<pre><code class="language-text">Calling simple function...
Calling collect...
Flow started
1
2
3
Calling collect again...
Flow started
1
2
3
</code></pre>
<p>这是<code>simple</code>函数（返回一个flow）没有标记<code>suspend</code>修饰符的关键原因。<br>
就其本身而言，<code>simple()</code>调用很快返回，不需要任何等待。flow每次被收集时都会启动。<br>
这就是为什么当我们再次调用<code>collect</code>时看到 &quot;Flow started&quot;。</p>
<h2 id="如何取消flow">如何取消Flow</h2>
<p>Flow 沿用了coroutine协同取消的做法。像往常一样，当Flow被暂停在一个可取消的suspend函数（如delay）中时，Flow收集可以被取消。下面的例子展示了当Flow在一个<code>withTimeoutOrNull</code>块中运行时, 如何在Timeout时被取消并停止执行其代码。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart           
fun simple(): Flow&lt;Int&gt; = flow { 
    for (i in 1..3) {
        delay(100)          
        println(&quot;Emitting $i&quot;)
        emit(i)
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    withTimeoutOrNull(250) { // Timeout after 250ms 
        simple().collect { value -&gt; println(value) } 
    }
    println(&quot;Done&quot;)
}
//sampleEnd
</code></pre>
<p>请注意，在<code>simple</code>函数中，只有两个数字是由Flow发出的，产生以下输出。</p>
<pre><code class="language-text">Emitting 1
1
Emitting 2
2
Done
</code></pre>
<h2 id="flow-构造器">Flow 构造器</h2>
<p>前面例子中的 <code>flow { ... }</code> 是最基本构建器之一。还有其他的构建器，用于<br>
Flow的声明。</p>
<ul>
<li>
<p><code>flowOf</code>构建器，它定义了固定数值集合的Flow。</p>
</li>
<li>
<p>各种<code>collections</code>和<code>sequences</code>可以使用<code>.asFlow()</code>扩展函数转换为Flow。</p>
</li>
</ul>
<p>因此，从一个Flow 中打印出1到3的数字的例子可以写成。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    // Convert an integer range to a flow
    (1..3).asFlow().collect { value -&gt; println(value) }
//sampleEnd 
}
</code></pre>
<pre><code>1
2
3
</code></pre>
<h2 id="flow-操作符">Flow 操作符</h2>
<p>Flow可以用运算符进行转换，就像你用 <em>collection</em> 和 <em>sequence</em> 一样。上游的 flow经转接运算符应用后会返回一个下游<em>flow</em>。这些运算符是被动的，就像<em>flow</em>一样。这种运算符的调用是立即地返回一个新的转换后的<em>flow</em>。基本运算符有着熟悉的名字，如<code>map</code>和<code>filter</code>。与sequence的重要区别是，这些操作符中的代码块中可以调用suspend 函数。</p>
<p>例如，一个传入的请求<em>flow</em>可以被用<code>map</code>操作符映射到返回结果中，即使执行一个请求是一个长时间运行的操作。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart           
suspend fun performRequest(request: Int): String {
    delay(1000) // imitate long-running asynchronous work
    return &quot;response $request&quot;
}

fun main() = runBlocking&lt;Unit&gt; {
    (1..3).asFlow() // a flow of requests
        .map { request -&gt; performRequest(request) }
        .collect { response -&gt; println(response) }
}
//sampleEnd
</code></pre>
<p>输出了以下三行，每行出现在每一秒钟之后。</p>
<pre><code class="language-text">response 1
response 2
response 3
</code></pre>
<h3 id="transform操作符">Transform操作符</h3>
<p>在Flow多个操作符中，最普遍的一个是 <code>transform</code>。它可以用来模仿像<code>map</code>和<code>map</code>的简单转换，以及实现更复杂的转换。使用<code>transform</code>操作符，我们可以<em>emit</em>任意的值，并不限制次数。</p>
<p>例如，我们使用<code>transform</code>时，可以在一个长时间的异步请求执行之前 <em>emit</em> 一个字符串<br>
并在其后<em>emit</em>一个响应：</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

suspend fun performRequest(request: Int): String {
    delay(1000) // imitate long-running asynchronous work
    return &quot;response $request&quot;
}

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    (1..3).asFlow() // a flow of requests
        .transform { request -&gt;
            emit(&quot;Making request $request&quot;) 
            emit(performRequest(request)) 
        }
        .collect { response -&gt; println(response) }
//sampleEnd
}
</code></pre>
<p>代码输出如下：</p>
<pre><code class="language-text">Making request 1
response 1
Making request 2
response 2
Making request 3
response 3
</code></pre>
<h3 id="size-limiting-操作符">Size-limiting 操作符</h3>
<p>当达到相应的限制时，像[take]这样的限制大小的中间操作符会取消流程的执行。 达到时，取消流程的执行。COROUTINE中的取消总是通过抛出一个异常来执行的，所以所有的资源管理 功能（如<code>try { ... } finally { ... }</code>块）在取消的情况下正常运行。</p>
<p>当达到相应的限制时，像<code>take</code>这样的Size-limiting的中间操作符会取消<em>flow</em>的执行， coroutines中的取消总是通过抛出一个异常来完成的，使得如Resouce管理的操作（如<code>try { ... } finally { ... }</code>块）在取消的情况时得以正常运行。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
fun numbers(): Flow&lt;Int&gt; = flow {
    try {                          
        emit(1)
        emit(2) 
        println(&quot;This line will not execute&quot;)
        emit(3)    
    } finally {
        println(&quot;Finally in numbers&quot;)
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    numbers() 
        .take(2) // take only the first two
        .collect { value -&gt; println(value) }
}            
//sampleEnd
</code></pre>
<p>这段代码的输出清楚地表明，<code>flow { ... }</code>主体在执行到 <code>numbers()</code><br>
发出第二个数字后就停止了。</p>
<pre><code class="language-text">1
2
Finally in numbers
</code></pre>
<h2 id="flow-结束操作符">Flow 结束操作符</h2>
<p><em>Flow</em>的结束运算符是_暂停的函数_，它触发了<em>Flow</em>的收集动作。<code>collect</code>操作符是最基本的一个，当然还有其他终端操作符。</p>
<ul>
<li>转换为各种集合，如<code>toList</code>和<code>toSet</code>。</li>
<li>获得<code>first</code>的操作符，并确保flow发出单值。</li>
<li>用<code>reduce</code>和<code>fold</code>将一个flow合并为一个值。</li>
</ul>
<p>比如说。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart         
    val sum = (1..5).asFlow()
        .map { it * it } // squares of numbers from 1 to 5                           
        .reduce { a, b -&gt; a + b } // sum them (terminal operator)
    println(sum)
//sampleEnd     
}
</code></pre>
<p>输出了单值</p>
<pre><code class="language-text">55
</code></pre>
<h2 id="连续的flows">连续的Flows</h2>
<p>在flow里面的每个单独的<em>collection</em>都是按顺序进行的，除非对多个<em>flow</em>的操作中使用了特殊操作符。<br>
Flow的采集工作会在结束运算符的所在coroutine下面进行。默认情况下，不会启动新的coroutine。<br>
每个<em>emit</em>的值都被所有的中间运算符处理，然后交付给结束运算符。</p>
<p>请看下面的例子，它过滤了偶数整数并将其映射为字符串。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart         
    (1..5).asFlow()
        .filter {
            println(&quot;Filter $it&quot;)
            it % 2 == 0              
        }              
        .map { 
            println(&quot;Map $it&quot;)
            &quot;string $it&quot;
        }.collect { 
            println(&quot;Collect $it&quot;)
        }    
//sampleEnd                  
}
</code></pre>
<p>代码输出如下：</p>
<pre><code class="language-text">Filter 1
Filter 2
Map 2
Collect string 2
Filter 3
Filter 4
Map 4
Collect string 4
Filter 5
</code></pre>
<h2 id="flow内部的context">Flow内部的context</h2>
<p>Flow的收集总是发生在调用coroutine的context中。例如，假如有一个 <code>simple</code> flow，那么下面的代码将在指定的context中运行，而不管<code>simple</code> flow的具体细节。</p>
<pre><code class="language-kotlin">withContext(context) {
    simple().collect { value -&gt;
        println(value) // run in the specified context 
    }
}
</code></pre>
<p>Flow这个属性被称为_context preservation_。因此，默认情况下，<code>flow { ... }</code>构造器中的代码在由相应Flow的收集器提供的context中运行。例如，假设一个 <code>simple</code>函数的实现是打印出被调用的线程的信息，它被调用后emit出三个数字。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun log(msg: String) = println(&quot;[${Thread.currentThread().name}] $msg&quot;)
           
//sampleStart
fun simple(): Flow&lt;Int&gt; = flow {
    log(&quot;Started simple flow&quot;)
    for (i in 1..3) {
        emit(i)
    }
}  

fun main() = runBlocking&lt;Unit&gt; {
    simple().collect { value -&gt; log(&quot;Collected $value&quot;) } 
}            
//sampleEnd
</code></pre>
<p>运行后输出：</p>
<pre><code class="language-text">[main @coroutine#1] Started simple flow
[main @coroutine#1] Collected 1
[main @coroutine#1] Collected 2
[main @coroutine#1] Collected 3
</code></pre>
<p>由于<code>simple().collect</code>是从<em>main</em>线程调用的，<code>simple</code>的flow主体也在<em>main</em>线程中调用。<br>
flow里的代码无论是同步或异步的也不会有影响，它不关心执行环境，也不阻塞调用者。</p>
<h3 id="使用withcontext抛出错误">使用withContext抛出错误</h3>
<p>然而，长时间运行的消耗CPU的代码可能需要在<code>Dispatchers.Default</code>的context中执行，而UI更新的代码可能需要在<code>Dispatchers.Main</code>的context中执行。通常情况下，<code>withContext</code>被用于来改变使用Kotlin coroutines的代码中的context，但在 <code>flow { ... }</code>构造器中的代码必须遵守保留context规定，不允许从不同的context中<code>emit</code></p>
<p>试着运行下面的代码。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
                      
//sampleStart
fun simple(): Flow&lt;Int&gt; = flow {
    // The WRONG way to change context for CPU-consuming code in flow builder
    kotlinx.coroutines.withContext(Dispatchers.Default) {
        for (i in 1..3) {
            Thread.sleep(100) // pretend we are computing it in CPU-consuming way
            emit(i) // emit next value
        }
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    simple().collect { value -&gt; println(value) } 
}            
//sampleEnd
</code></pre>
<p>这段代码产生了以下异常</p>
<pre><code class="language-text">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Flow invariant is violated:
		Flow was collected in [CoroutineId(1), &quot;coroutine#1&quot;:BlockingCoroutine{Active}@5511c7f8, BlockingEventLoop@2eac3323],
		but emission happened in [CoroutineId(1), &quot;coroutine#1&quot;:DispatchedCoroutine{Active}@2dae0000, Dispatchers.Default].
		Please refer to 'flow' documentation or use 'flowOn' instead
	at ...
</code></pre>
<h3 id="flowon-操作符">flowOn 操作符</h3>
<p>这还是有例外的，<code>flowOn</code>函数，该函数应被用来改变<em>flow</em> 在 emit 时的context。改变flow的context的正确方法可以参考下面例子，该例子还打印了相应<em>Thread</em>的名称，以显示这一切是如何执行的。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun log(msg: String) = println(&quot;[${Thread.currentThread().name}] $msg&quot;)
           
//sampleStart
fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        Thread.sleep(100) // pretend we are computing it in CPU-consuming way
        log(&quot;Emitting $i&quot;)
        emit(i) // emit next value
    }
}.flowOn(Dispatchers.Default) // RIGHT way to change context for CPU-consuming code in flow builder

fun main() = runBlocking&lt;Unit&gt; {
    simple().collect { value -&gt;
        log(&quot;Collected $value&quot;) 
    } 
}            
//sampleEnd
</code></pre>
<p>代码输出结果：</p>
<pre><code>[DefaultDispatcher-worker-1 @coroutine#2] Emitting 1
[main @coroutine#1] Collected 1
[DefaultDispatcher-worker-1 @coroutine#2] Emitting 2
[main @coroutine#1] Collected 2
[DefaultDispatcher-worker-1 @coroutine#2] Emitting 3
[main @coroutine#1] Collected 3
</code></pre>
<p>注意<code>flow { ... }</code>在后台thread中工作，而<em>flow</em>收集则发生在main thread中。</p>
<p>另注意的是，<em>flowOn</em>操作符改变了flow的顺序性。假设现在有一个Flow，collect发生在一个coroutine（&quot;coroutine#1&quot;）中，emit发生在另一个coroutine（&quot;coroutine#2&quot;）中。它与收集的coroutine同时在另一个Thread中运行。<em>flowOn</em>操作符，当它必须改变其context中的<code>CoroutineDispatcher</code>时，会为一个上游Flow创建另一个coroutine。</p>
<h2 id="buffering">Buffering</h2>
<p>从收集flow的整体时间的角度来看，在不同的coroutines中运行Flow的不同部分可能是有帮助的，特别是当涉及到长时间运行的异步操作时。假设有一种情况：一个 <code>simple</code>  flow的emit很慢，产生一个元素需要100毫秒；而收集器也很慢，处理一个元素需要300毫秒。让我们看看用收集三个数字用的这样一个flow需要多长时间。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlin.system.*

//sampleStart
fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        delay(100) // pretend we are asynchronously waiting 100 ms
        emit(i) // emit next value
    }
}

fun main() = runBlocking&lt;Unit&gt; { 
    val time = measureTimeMillis {
        simple().collect { value -&gt; 
            delay(300) // pretend we are processing it for 300 ms
            println(value) 
        } 
    }   
    println(&quot;Collected in $time ms&quot;)
}
//sampleEnd
</code></pre>
<p>产生的结果是这样的，整个集合大约需要1200毫秒（三个数字，每个400毫秒）。</p>
<pre><code class="language-text">1
2
3
Collected in 1220 ms
</code></pre>
<p>我们可以在一个flow上使用<code>buffer</code>操作符来运行 <code>simple</code> flow 的emit和collect。而不是按顺序运行它们。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlin.system.*

fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        delay(100) // pretend we are asynchronously waiting 100 ms
        emit(i) // emit next value
    }
}

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart
    val time = measureTimeMillis {
        simple()
            .buffer() // buffer emissions, don't wait
            .collect { value -&gt; 
                delay(300) // pretend we are processing it for 300 ms
                println(value) 
            } 
    }   
    println(&quot;Collected in $time ms&quot;)
//sampleEnd
}
</code></pre>
<p>它产生同样的数字，但速度更快了，因为我们创建了一个处理管道。只需等待100毫秒的第一个数字，然后只需花费300毫秒来处理每个数字。这样一来，它的运行时间大约为1000毫秒。</p>
<pre><code class="language-text">1
2
3
Collected in 1071 ms
</code></pre>
<blockquote>
<p>请注意，当flowOn操作者必须改变CoroutineDispatcher时，它使用了同样的缓冲机制。但这里我们明确要求缓冲，而不改变执行环境。</p>
</blockquote>
<h3 id="conflation冲突">Conflation(冲突)</h3>
<p>当一个Flow操作的部分结果或状态更新时，可能没有必要处理每个值，而是只处理最近的值。在这种情况下，当收集器处理速度太慢时,可以用<code>conflate</code>操作符来跳过。在前面的例子的基础上。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlin.system.*

fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        delay(100) // pretend we are asynchronously waiting 100 ms
        emit(i) // emit next value
    }
}

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart
    val time = measureTimeMillis {
        simple()
            .conflate() // conflate emissions, don't process each one
            .collect { value -&gt; 
                delay(300) // pretend we are processing it for 300 ms
                println(value) 
            } 
    }   
    println(&quot;Collected in $time ms&quot;)
//sampleEnd
}
</code></pre>
<p>我们看到，当第一个数字还在处理的时候，第二个和第三个数字已经生产出来了，所以第二个数字冲突了，只有最近的（第三个）被收集。</p>
<pre><code class="language-text">1
3
Collected in 758 ms
</code></pre>
<h3 id="collectlatest-仅处理最新">CollectLatest (仅处理最新)</h3>
<p>当发射器和收集器都很慢时，<code>conflate</code>是加速处理的一种方法。它通过丢弃发射的值来实现。<br>
另一种方法是取消缓慢的收集器，并在每次有新值emit时重新启动它。这里有一系列的<code>xxxLatest</code>操作符，执行与<code>xxx</code>操作符相同的基本逻辑，但在新值时取消其取消其块中的代码。让我们试着把前面例子中的<code>conflate</code>改为<code>collectLatest</code>。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlin.system.*

fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        delay(100) // pretend we are asynchronously waiting 100 ms
        emit(i) // emit next value
    }
}

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart
    val time = measureTimeMillis {
        simple()
            .collectLatest { value -&gt; // cancel &amp; restart on the latest value
                println(&quot;Collecting $value&quot;) 
                delay(300) // pretend we are processing it for 300 ms
                println(&quot;Done $value&quot;) 
            } 
    }   
    println(&quot;Collected in $time ms&quot;)
//sampleEnd
}
</code></pre>
<p>由于<code>collectLatest</code>里的代码需要300毫秒，但每100毫秒就会有新的值发出来，可以看到，这个块<br>
是在每个值上运行的，但只完成了最后一个值。</p>
<pre><code class="language-text">Collecting 1
Collecting 2
Collecting 3
Done 3
Collected in 741 ms
</code></pre>
<h2 id="组合多个flows">组合多个Flows</h2>
<p>组合多个Flow有很多的方法。</p>
<h3 id="zip">Zip</h3>
<p>就像Kotlin标准库中的<code>Sequence.zip</code>扩展函数一样，flow 也有一个<em>zip</em>操作符，可以将两个flow的相应值结合起来。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart                                                                           
    val nums = (1..3).asFlow() // numbers 1..3
    val strs = flowOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) // strings 
    nums.zip(strs) { a, b -&gt; &quot;$a -&gt; $b&quot; } // compose a single string
        .collect { println(it) } // collect and print
//sampleEnd
}
</code></pre>
<p>代码运行输出:</p>
<pre><code class="language-text">1 -&gt; one
2 -&gt; two
3 -&gt; three
</code></pre>
<h3 id="combine">Combine</h3>
<p>当Flow代表的是一个变量或操作的最新值时，在上游流emit一个值， 需要重新执行一个相应Flow的最新值的计算。相应的操作符是<code>combine</code>。</p>
<p>例如，如果前面例子中的数字每300ms更新一次，但字符串每400ms更新一次。那么使用<code>zip</code>运算符对它们进行压缩，仍然会产生相同的结果。尽管结果是每400毫秒打印一次。</p>
<blockquote>
<p>在这个例子中，我们使用<code>onEach</code>操作符来延迟每个元素，</p>
<p>使flow里emit代码更加声明化和简单。</p>
</blockquote>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart                                                                           
    val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms
    val strs = flowOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;).onEach { delay(400) } // strings every 400 ms
    val startTime = System.currentTimeMillis() // remember the start time 
    nums.zip(strs) { a, b -&gt; &quot;$a -&gt; $b&quot; } // compose a single string with &quot;zip&quot;
        .collect { value -&gt; // collect and print 
            println(&quot;$value at ${System.currentTimeMillis() - startTime} ms from start&quot;) 
        } 
//sampleEnd
}
</code></pre>
<p>输出结果：</p>
<pre><code>1 -&gt; one at 437 ms from start
2 -&gt; two at 837 ms from start
3 -&gt; three at 1243 ms from start
</code></pre>
<p>然而，当在这里使用<code>combine</code>运算符而不是<code>zip</code>时:</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart                                                                           
    val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms
    val strs = flowOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;).onEach { delay(400) } // strings every 400 ms          
    val startTime = System.currentTimeMillis() // remember the start time 
    nums.combine(strs) { a, b -&gt; &quot;$a -&gt; $b&quot; } // compose a single string with &quot;combine&quot;
        .collect { value -&gt; // collect and print 
            println(&quot;$value at ${System.currentTimeMillis() - startTime} ms from start&quot;) 
        } 
//sampleEnd
}
</code></pre>
<p>我们得到了不同的输出，每当从<code>nums</code>或<code>strs</code>流中emit时都会打印一行。</p>
<pre><code class="language-text">1 -&gt; one at 452 ms from start
2 -&gt; one at 651 ms from start
2 -&gt; two at 854 ms from start
3 -&gt; two at 952 ms from start
3 -&gt; three at 1256 ms from start
</code></pre>
<h2 id="扁平化-flows">扁平化 Flows</h2>
<p>Flows 代表了异步接收数值的<em>sequences</em>，所以很容易出现这样的情况：每个值都会触发对另一个值sequences 的请求。例如，我们这有一个返回相隔500ms的两个字符串的Flow的函数。</p>
<pre><code class="language-kotlin">fun requestFlow(i: Int): Flow&lt;String&gt; = flow {
    emit(&quot;$i: First&quot;) 
    delay(500) // wait 500 ms
    emit(&quot;$i: Second&quot;)    
}
</code></pre>
<p>现在，如果我们有一个由三个<em>integer</em>组成的流，并为每个<em>integer</em>调用<code>requestFlow</code>。</p>
<pre><code class="language-kotlin">(1..3).asFlow().map { requestFlow(it) }
</code></pre>
<p>然后，我们最终得到一个流（<code>Flow&lt;Flow&lt;String&gt;</code>），它需要把它扁平化成一个单流，以便进一步处理。<em>Collections</em>和<em>Sequences</em>有[flatten][Sequence.flatten]和[flatMap][Sequence.flatMap]这两个操作符来实现这一点。然而，由于Flow的异步性，它们需要不同的扁平化方式。因此，在Flow里有一系列的扁平化操作符。</p>
<h3 id="flatmapconcat">flatMapConcat</h3>
<p>连接模式由 <em>flatMapConcat</em> 和 <em>flattenConcat</em> 操作符实现。它们是最类似于的<em>sequence</em>操作符。它们在开始收集下一个Flow之前，会等待内部Flow完成, 才开始收集下一个Flow，如下面的例子所示</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun requestFlow(i: Int): Flow&lt;String&gt; = flow {
    emit(&quot;$i: First&quot;) 
    delay(500) // wait 500 ms
    emit(&quot;$i: Second&quot;)    
}

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart
    val startTime = System.currentTimeMillis() // remember the start time 
    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms 
        .flatMapConcat { requestFlow(it) }                                                                           
        .collect { value -&gt; // collect and print 
            println(&quot;$value at ${System.currentTimeMillis() - startTime} ms from start&quot;) 
        } 
//sampleEnd
}
</code></pre>
<p>在输出中可以清楚地看到<code>flatMapConcat</code>的连续性</p>
<pre><code class="language-text">1: First at 121 ms from start
1: Second at 622 ms from start
2: First at 727 ms from start
2: Second at 1227 ms from start
3: First at 1328 ms from start
3: Second at 1829 ms from start
</code></pre>
<h3 id="flatmapmerge">flatMapMerge</h3>
<p>另一种扁平化模式是同时收集所有传入的Flow，并将它们的值合并成一个单一的流，这样就可以尽快地emit出值。它由<code>flatMapMerge</code>和<code>flattenMerge</code>操作符实现。它们都接受一个可选<code>concurrency</code>参数，限制同时收集的并发Flow的数量。(它默认是<em>DEFAULT_CONCURRENCY</em>)</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun requestFlow(i: Int): Flow&lt;String&gt; = flow {
    emit(&quot;$i: First&quot;) 
    delay(500) // wait 500 ms
    emit(&quot;$i: Second&quot;)    
}

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart
    val startTime = System.currentTimeMillis() // remember the start time 
    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms 
        .flatMapMerge { requestFlow(it) }                                                                           
        .collect { value -&gt; // collect and print 
            println(&quot;$value at ${System.currentTimeMillis() - startTime} ms from start&quot;) 
        } 
//sampleEnd
}
</code></pre>
<p><em>flatMapMerge</em>的并发性是显而易见的</p>
<pre><code class="language-text">1: First at 136 ms from start
2: First at 231 ms from start
3: First at 333 ms from start
1: Second at 639 ms from start
2: Second at 732 ms from start
3: Second at 833 ms from start
</code></pre>
<blockquote>
<p>注意，<code>flatMapMerge</code>是按顺序调用其代码块（本例中为<code>{ requestFlow(it) }</code>），但同时收集所产生的流量，它相当于先顺序执行的<code>map { requestFlow(it) }</code>，然后对结果调用<code>flattenMerge</code>。</p>
</blockquote>
<h3 id="flatmaplatest">flatMapLatest</h3>
<p>与<code>collectLatest</code>操作符类似，扁平化Flow也有相应的 <code>Latest</code>模式。在这种模式下，一旦有新的流量发出，就会取消对先前Flow的收集。它是由<code>flatMapLatest</code>操作符实现的。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun requestFlow(i: Int): Flow&lt;String&gt; = flow {
    emit(&quot;$i: First&quot;) 
    delay(500) // wait 500 ms
    emit(&quot;$i: Second&quot;)    
}

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart
    val startTime = System.currentTimeMillis() // remember the start time 
    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms 
        .flatMapLatest { requestFlow(it) }                                                                           
        .collect { value -&gt; // collect and print 
            println(&quot;$value at ${System.currentTimeMillis() - startTime} ms from start&quot;) 
        } 
//sampleEnd
}
</code></pre>
<p>这个例子中的输出是解释了 <code>flatMapLatest</code>工作方式。</p>
<pre><code class="language-text">1: First at 142 ms from start
2: First at 322 ms from start
3: First at 425 ms from start
3: Second at 931 ms from start
</code></pre>
<blockquote>
<p>请注意，<code>flatMapLatest</code> 在新的emit值后取消了执行它里面的块代码（本例中的<code>{ requestFlow(it) }</code>）。在这个特定的例子中没有什么区别，因为对<code>requestFlow</code>的调用本身是快速的，不暂停的。并且不能被取消。然而，如果我们在其中使用像<code>delay</code>这样的暂停函数，它就会显示出来</p>
</blockquote>
<h2 id="flow-的异常处理">Flow 的异常处理</h2>
<p>当发射器或Flow转换符内部抛出一个异常时，Flow的收集也可以正常完成。处理这些异常有几种方法。</p>
<h3 id="收集器使用-try-and-catch">收集器使用 try and catch</h3>
<p>采集器可以使用Kotlin的[<code>try/catch</code>][exceptions]块来处理异常。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        println(&quot;Emitting $i&quot;)
        emit(i) // emit next value
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    try {
        simple().collect { value -&gt;         
            println(value)
            check(value &lt;= 1) { &quot;Collected $value&quot; }
        }
    } catch (e: Throwable) {
        println(&quot;Caught $e&quot;)
    } 
}            
//sampleEnd
</code></pre>
<p>这段代码捕获了collect 结束操作符的一个异常，并且。正如我们所看到的，在那之后就没有更多的值被释放出来。</p>
<pre><code class="language-text">Emitting 1
1
Emitting 2
2
Caught java.lang.IllegalStateException: Collected 2
</code></pre>
<h3 id="一切皆可捕获">一切皆可捕获</h3>
<p>在前面的例子中，捕获的都是发生在发射器或任何中间或结束运算符中的任何异常。<br>
让我们改变代码，使emit的值被[mapped][map]为字符串。但相应的代码会产生一个异常。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
fun simple(): Flow&lt;String&gt; = 
    flow {
        for (i in 1..3) {
            println(&quot;Emitting $i&quot;)
            emit(i) // emit next value
        }
    }
    .map { value -&gt;
        check(value &lt;= 1) { &quot;Crashed on $value&quot; }                 
        &quot;string $value&quot;
    }

fun main() = runBlocking&lt;Unit&gt; {
    try {
        simple().collect { value -&gt; println(value) }
    } catch (e: Throwable) {
        println(&quot;Caught $e&quot;)
    } 
}            
//sampleEnd
</code></pre>
<p>这次仍可以捕获异常，并停止收集。</p>
<pre><code class="language-text">Emitting 1
string 1
Emitting 2
Caught java.lang.IllegalStateException: Crashed on 2
</code></pre>
<h2 id="exception的可见性">Exception的可见性</h2>
<p>在发射器的代码中如何处理好异常的？ Flow对异常必须透明可见的，如果在 <code>flow { ... }</code>构建器块中，用 <code>try/catch</code>块包裹着 emit的值，是违反 <code>异常透明可见</code>的原则的，因为。这保证了抛出异常的收集器可以像前面的例子一样使用<code>try/catch</code>来捕获它。发射器可以使用一个<code>catch</code>操作符来保留这个异常的透明可见，并允许对它的进行异常处理。<code>catch</code>操作符的主体可以识别异常，并以不同的方式对其作出处理，这取决于捕获的是哪种异常。</p>
<ul>
<li>异常可以用<code>throw</code>重新抛出。</li>
<li>异常可以通过<code>catch</code>的主体使用[emit][FlowCollector.emit]将其变成数值来emit。</li>
<li>异常可以被忽略、记录，或者被其他代码处理。</li>
</ul>
<p>例如，让我们在捕捉到一个异常时emit出字符串。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun simple(): Flow&lt;String&gt; = 
    flow {
        for (i in 1..3) {
            println(&quot;Emitting $i&quot;)
            emit(i) // emit next value
        }
    }
    .map { value -&gt;
        check(value &lt;= 1) { &quot;Crashed on $value&quot; }                 
        &quot;string $value&quot;
    }

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    simple()
        .catch { e -&gt; emit(&quot;Caught $e&quot;) } // emit on exception
        .collect { value -&gt; println(value) }
//sampleEnd
}            
</code></pre>
<p>尽管我们在代码周围不再有<code>try/catch</code>，但该例子的输出是一样的。</p>
<pre><code>Emitting 1
string 1
Emitting 2
Caught java.lang.IllegalStateException: Crashed on 2
</code></pre>
<h3 id="透明的catch">透明的catch</h3>
<p><code>catch</code>操作符遵循着异常的透明可见的原则，只捕获上游的异常 (即只来自<code>catch</code>上游的操作符的异常，不包含下游)。如果在 <code>collect { ... }</code>中的代码块（放在<code>catch</code>下面）抛出一个异常，那么它就不能被捕获。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        println(&quot;Emitting $i&quot;)
        emit(i)
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    simple()
        .catch { e -&gt; println(&quot;Caught $e&quot;) } // does not catch downstream exceptions
        .collect { value -&gt;
            check(value &lt;= 1) { &quot;Collected $value&quot; }                 
            println(value) 
        }
}            
//sampleEnd
</code></pre>
<p>尽管有一个<code>catch</code>操作符，但没有打印出 &quot;Caught ... &quot;。</p>
<pre><code class="language-text">Emitting 1
1
Emitting 2
Exception in thread &quot;main&quot; java.lang.IllegalStateException: Collected 2
	at ...
</code></pre>
<h3 id="声明式catch">声明式catch</h3>
<p>我们可以声明性流程和处理异常相结合起来，把<code>collect</code>操作符的主体移到移到<code>onEach</code>中，并把它放在  <code>catch</code>操作符之前，  Flow的收集必须调用 <code>collect()</code> 来触发，不需要参数。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        println(&quot;Emitting $i&quot;)
        emit(i)
    }
}

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    simple()
        .onEach { value -&gt;
            check(value &lt;= 1) { &quot;Collected $value&quot; }                 
            println(value) 
        }
        .catch { e -&gt; println(&quot;Caught $e&quot;) }
        .collect()
//sampleEnd
}            
</code></pre>
<p>现在我们可以看到，一个 &quot;Caught获...... &quot;的消息被打印出来，因此我们不需要用<code>try/catch</code>块就可以捕获所有的异常。</p>
<pre><code class="language-text">Emitting 1
1
Emitting 2
Caught java.lang.IllegalStateException: Collected 2
</code></pre>
<h2 id="flow的收集完成">Flow的收集完成</h2>
<p>当Flow收集完成后（正常或异常）可能需要执行某些动作。它可以用两种方式来完成：命令式或声明式。</p>
<h3 id="命令式-finally-block">命令式 finally block</h3>
<p>除了<code>try/catch</code>，收集器还可以使用 <code>finally</code> 块，在 <code>collect</code>完成后执行某些动作。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
fun simple(): Flow&lt;Int&gt; = (1..3).asFlow()

fun main() = runBlocking&lt;Unit&gt; {
    try {
        simple().collect { value -&gt; println(value) }
    } finally {
        println(&quot;Done&quot;)
    }
}            
//sampleEnd
</code></pre>
<p>这段代码打印了<code>simple</code>产生的三个数字，后面是一个 &quot;Done &quot;字符串。</p>
<pre><code class="language-text">1
2
3
Done
</code></pre>
<h3 id="声明式处理">声明式处理</h3>
<p>Flow有<code>onCompletion</code>中间操作符来声明式完成，在Flow收集完成后被调用。</p>
<p>前面的例子可以用<code>onCompletion</code>重写，并产生相同的输出。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun simple(): Flow&lt;Int&gt; = (1..3).asFlow()

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    simple()
        .onCompletion { println(&quot;Done&quot;) }
        .collect { value -&gt; println(value) }
//sampleEnd
}            
</code></pre>
<pre><code>1
2
3
Done
</code></pre>
<p>使用<code>onCompletion</code>的关键优势是，在lambda中的第一个可为<em>null</em>的<code>Throwable</code>参数，可以用来确定Flow的收集是正常完成还是出现了异常。</p>
<p>在下面的例子中，<code>simple</code>在emit数字1后抛出了一个异常。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
fun simple(): Flow&lt;Int&gt; = flow {
    emit(1)
    throw RuntimeException()
}

fun main() = runBlocking&lt;Unit&gt; {
    simple()
        .onCompletion { cause -&gt; if (cause != null) println(&quot;Flow completed exceptionally&quot;) }
        .catch { cause -&gt; println(&quot;Caught exception&quot;) }
        .collect { value -&gt; println(value) }
}            
//sampleEnd
</code></pre>
<p>代码输出结果</p>
<pre><code class="language-text">1
Flow completed exceptionally
Caught exception
</code></pre>
<p>与<code>catch</code>不同，<code>onCompletion</code>操作符并不处理异常。正如我们从上面示例代码中可以看到，这个异常仍然在向下游传递。它将被传递给更多的  <code>onCompletion</code>&quot;操作符, 并可以用 <code>catch</code> 操作符来处理。</p>
<h3 id="成功完成">成功完成</h3>
<p>与<code>catch</code>操作符的另一个区别是，<code>onCompletion</code>可以捕获所有的异常，</p>
<p>而只有在上游flow成功完成（没有取消或失败）时才会收到一个 <code>null</code>异常。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
fun simple(): Flow&lt;Int&gt; = (1..3).asFlow()

fun main() = runBlocking&lt;Unit&gt; {
    simple()
        .onCompletion { cause -&gt; println(&quot;Flow completed with $cause&quot;) }
        .collect { value -&gt;
            check(value &lt;= 1) { &quot;Collected $value&quot; }                 
            println(value) 
        }
}
//sampleEnd
</code></pre>
<p>我们可以看到完成的原因不是<em>null</em>，因为Flow是由于下游的异常而中止的。</p>
<pre><code class="language-text">1
Flow completed with java.lang.IllegalStateException: Collected 2
Exception in thread &quot;main&quot; java.lang.IllegalStateException: Collected 2
</code></pre>
<h2 id="命令式与声明式">命令式与声明式</h2>
<p>现在我们知道如何收集Flow，并以<em>命令式</em>和<em>声明式</em>的方式处理其完成和异常。这里的自然问题是，哪种方法是首选，为什么？作为一个库，我们不提倡任何特定的方法，并相信这两种选择都是有效的，应该根据你自己的喜好和代码风格来选择。</p>
<h2 id="启动-flow">启动 flow</h2>
<p>使用flow来表示来自某些源产生异步事件是很容易的。在这种情况下，我们需要一个类似于 <code>addEventListener</code>的函数，该函数将回调与事件结合一起了。<code>onEach</code>操作符可以起到这个作用。<br>
然而，<code>onEach</code>是一个中间操作符。我们还需要一个结束操作符来收集流量。否则，仅仅调用<code>onEach</code>就没有任何效果。</p>
<p>如果我们在<code>onEach</code>之后使用<code>collect</code>结束操作符，那么后面的代码就会等待，直到流量被收集。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
// Imitate a flow of events
fun events(): Flow&lt;Int&gt; = (1..3).asFlow().onEach { delay(100) }

fun main() = runBlocking&lt;Unit&gt; {
    events()
        .onEach { event -&gt; println(&quot;Event: $event&quot;) }
        .collect() // &lt;--- Collecting the flow waits
    println(&quot;Done&quot;)
}            
//sampleEnd
</code></pre>
<p>代码输出如下：</p>
<pre><code class="language-text">Event: 1
Event: 2
Event: 3
Done
</code></pre>
<p><code>launchIn</code>结束操作符在这里派上了用场。通过用<code>launchIn</code>代替<code>collect</code>，我们可以<br>
我们可以在一个单独的coroutine中启动一个flow的的收集，这样其余代码将立即继续执行。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

// Imitate a flow of events
fun events(): Flow&lt;Int&gt; = (1..3).asFlow().onEach { delay(100) }

//sampleStart
fun main() = runBlocking&lt;Unit&gt; {
    events()
        .onEach { event -&gt; println(&quot;Event: $event&quot;) }
        .launchIn(this) // &lt;--- Launching the flow in a separate coroutine
    println(&quot;Done&quot;)
}            
//sampleEnd
</code></pre>
<p>输入如下</p>
<pre><code class="language-text">Done
Event: 1
Event: 2
Event: 3
</code></pre>
<p><code>launchIn</code>的必要参数必须指定一个<code>CoroutineScope</code>，收集flow的coroutine会在这个scope内启动。在上面的例子中，这个CoroutineScope来自<code>runBlocking</code>的coroutine builder，所以当Flow运行时，这个<code>runBlocking</code>的CoroutineScope会等待其子coroutine的完成，并使main函数不返回。</p>
<p>在实际应用中，scope一般来自有着短暂生命周期的实体。一旦这个实体的生命周期被终止，相应的作用域就被取消，相应流量的收集也会被取消。这样，<code>onEach { ... }.launchIn(scope)</code>的工作方式<br>
就像 <code>addEventListener</code>。然而，不需要相应的<code>removeEventListener</code>函数。因为取消和结构化并发的设计已经解决这场景。</p>
<p>注意，<code>launchIn</code>也会返回一个<code>Job</code>，它可以在不取消整个scope的情况下<code>cancel</code>用来Flow收集的coroutine，或者用来[join][Job.join]它。</p>
<h3 id="flow-取消检查">Flow 取消检查</h3>
<p>为了方便起见，[flow][_flow]构建器对每个emit的值进行额外的<code>ensureActive</code>检查，以确保取消。<br>
这意味着，从<code>flow { ... }</code>是可以取消的。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart           
fun foo(): Flow&lt;Int&gt; = flow { 
    for (i in 1..5) {
        println(&quot;Emitting $i&quot;) 
        emit(i) 
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    foo().collect { value -&gt; 
        if (value == 3) cancel()  
        println(value)
    } 
}
//sampleEnd
</code></pre>
<p>We get only numbers up to 3 and a [CancellationException] after trying to emit number 4:</p>
<pre><code class="language-text">Emitting 1
1
Emitting 2
2
Emitting 3
3
Emitting 4
Exception in thread &quot;main&quot; kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=&quot;coroutine#1&quot;:BlockingCoroutine{Cancelled}@6d7b4f4c
</code></pre>
<p>然而，大多数流操作符出于性能方面的考虑不会做额外的取消检查。<br>
例如，如果你使用<code>IntRange.asFlow</code>扩展来写busy的loop，并且不在任何地方暂停。那么就不会有取消的检查了。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart           
fun main() = runBlocking&lt;Unit&gt; {
    (1..5).asFlow().collect { value -&gt; 
        if (value == 3) cancel()  
        println(value)
    } 
}
//sampleEnd
</code></pre>
<p>所有从1到5的数字都被收集起来，只有在从 <code>runBlocking</code>返回之前才会检测到取消。</p>
<pre><code class="language-text">1
2
3
4
5
Exception in thread &quot;main&quot; kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=&quot;coroutine#1&quot;:BlockingCoroutine{Cancelled}@3327bd23
</code></pre>
<h4 id="使运行中的flow可取消">使运行中的flow可取消</h4>
<p>在你有coroutines的运行着的情况下，你必须显式地检查取消。你可以添加<code>.onEach { currentCoroutineContext().sureActive() }</code>，但是可以用<code>cancellable</code> 操作符来实现。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart           
fun main() = runBlocking&lt;Unit&gt; {
    (1..5).asFlow().cancellable().collect { value -&gt; 
        if (value == 3) cancel()  
        println(value)
    } 
}
//sampleEnd
</code></pre>
<p>在 <code>cancellable</code>&quot;操作符中，只有1到3的数字被收集。</p>
<pre><code class="language-text">1
2
3
Exception in thread &quot;main&quot; kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=&quot;coroutine#1&quot;:BlockingCoroutine{Cancelled}@5ec0a365
</code></pre>
<h2 id="flow-与-reactive-streams">Flow 与 Reactive Streams</h2>
<p>对于那些熟悉<a href="https://www.reactive-streams.org/">Reactive Streams</a>或RxJava和 Reactor等反应式框架的人来说，Flow的设计可能看起来非常熟悉。的确，它的设计受了Reactive Stream和其他实现的启发。但Flow的主要目标是拥有尽可能简单的设计，对Kotlin和suspension友好，并遵循结构化的并发性的原则。如果没有Reactive的先驱者和他们的巨大工作，是不可能实现这个目标的。你可以在[Reactive Streams and Kotlin Flows](https://medium.com/@elizarov/reactive-streams and-kotlin-flows-bfd12772cda4)文章中阅读完整的故事。</p>
<p>虽然有所不同，但从概念上讲，<code>Flow</code>的确是一个reactive流，可以将其转换为reactive（符合规范和TCK）的Publisher，反之亦然。<code>kotlinx.coroutines</code>有提供这样的转换器，并且可以在相应的reactive模块中找到（<code>kotlinx-coroutines-reactive</code>用于反应式流，<code>kotlinx-coroutines-reactor</code>用于反应器，<code>kotlinx-coroutines-rx2</code>/<code>kotlinx-coroutines-rx3</code>用于RxJava2/RxJava3）。 集成模块包括从 <code>Flow</code>到 <code>Flow</code>的转换，Reactor <code>Context</code>的集成，以及与各种reactive 对象的提供友好的suspension集成方式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin Coroutine Part 4. Coroutine context and dispatchers]]></title>
        <id>https://waltcow.github.io/post/kotlin-coroutine-part-4-coroutine-context-and-dispatchers/</id>
        <link href="https://waltcow.github.io/post/kotlin-coroutine-part-4-coroutine-context-and-dispatchers/">
        </link>
        <updated>2021-07-29T03:20:50.000Z</updated>
        <summary type="html"><![CDATA[<p>这一节将介绍Coroutine 的上下文和调度器的使用</p>
]]></summary>
        <content type="html"><![CDATA[<p>这一节将介绍Coroutine 的上下文和调度器的使用</p>
<!-- more -->
<p>Coroutine总是在某些context中执行，这些context都是Kotlin标准库中定义的<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a>类型。</p>
<p>Coroutine 中的context 是一个多个变量集合。主要的变量是我们之前提到过的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>，以及它的<em>dispatcher</em>，这部分会在这节会提到。</p>
<h2 id="dispatchers和thread">Dispatchers和Thread</h2>
<p>Coroutine 的context包括一个<em>coroutine dispatcher</em>（见<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher</a>），它决定了对应的coroutine使用什么线程来执行。Coroutine dispatcher可以将coroutine的执行限制在一个特定的线程中，或将其分派调度到一个线程池中执行，或让它不受限制地运行。</p>
<p>所有coroutine的构建器如<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a>和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a>, 都接受一个可选的<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a>参数，可以用来指定新coroutine的 <em>dispatcher</em> 和context上的其他变量。</p>
<p>试试下面的例子</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    launch { // context of the parent, main runBlocking coroutine
        println(&quot;main runBlocking      : I'm working in thread ${Thread.currentThread().name}&quot;)
    }
    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread
        println(&quot;Unconfined            : I'm working in thread ${Thread.currentThread().name}&quot;)
    }
    launch(Dispatchers.Default) { // will get dispatched to DefaultDispatcher 
        println(&quot;Default               : I'm working in thread ${Thread.currentThread().name}&quot;)
    }
    launch(newSingleThreadContext(&quot;MyOwnThread&quot;)) { // will get its own new thread
        println(&quot;newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}&quot;)
    }
//sampleEnd    
}
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-text">Unconfined            : I'm working in thread main
Default               : I'm working in thread DefaultDispatcher-worker-1
newSingleThreadContext: I'm working in thread MyOwnThread
main runBlocking      : I'm working in thread main
</code></pre>
<p>当<code>launch { ... }</code> 以无参数的方式启动时，它继承了它调用者的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>的context（也就是调度器）。在上面的例子中，它继承了在 <code>main</code>线程中运行的 <code>runBlocking</code> 的context。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html">Dispatchers.Unconfined</a>是一个特殊的调度器，看起来也是在<code>main</code>线程中运行，但事实上，它是一种不同的机制，后面会解释。</p>
<p>当在作用域中没有明确指定其他调度器时，会使用默认的调度器。它由<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html">Dispatchers.Default</a>表示，并使用一个共享的后台线程池。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html">newSingleThreadContext</a>为coroutine创建一个线程来运行。一个专门的线程是一种非常昂贵的资源。在实际应用中，当线程不再需要时，必须使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-executor-coroutine-dispatcher/close.html">close</a>函数将其释放，或者将其存储在一个顶层变量中，在整个应用中重复使用。</p>
<h2 id="非封闭式和封闭式dispatchers">非封闭式和封闭式Dispatchers</h2>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html">Dispatchers.Unconfined</a>  dispatcher会在调用者线程中，当直到第一个暂停点才启动一个coroutine。</p>
<p>在暂停之后，该coroutine的恢复完全由被调用的暂停函数的线程所决定 。<em>Unconfined dispatcher</em> 适合于那种处在一个特定线程内执行既不消耗CPU，也不更新任何共享数据（如UI）的coroutines。</p>
<p>在另一边，<em>dispatcher</em> 默认从外部 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> 继承。譬如 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a> coroutine中默认的dispatcher将会被限制在调用者线程中。因此它的coroutine将限制在这个线程中并遵循FIFO调度</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread
        println(&quot;Unconfined      : I'm working in thread ${Thread.currentThread().name}&quot;)
        delay(500)
        println(&quot;Unconfined      : After delay in thread ${Thread.currentThread().name}&quot;)
    }
    launch { // context of the parent, main runBlocking coroutine
        println(&quot;main runBlocking: I'm working in thread ${Thread.currentThread().name}&quot;)
        delay(1000)
        println(&quot;main runBlocking: After delay in thread ${Thread.currentThread().name}&quot;)
    }
//sampleEnd    
}
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-text">Unconfined      : I'm working in thread main
main runBlocking: I'm working in thread main
Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor
main runBlocking: After delay in thread main
</code></pre>
<p>因此，从 <code>runBlocking {...}</code>继承的上下文的coroutine将继续在<code>main</code>线程中执行，而<em>Unconfined</em>的coroutine则在<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a>函数使用的默认执行器线程中恢复。</p>
<blockquote>
<p>Unconfined 调度器是一种先进的实现机制，在某些个别的情况下可能会很有用，在这些情况下，不需要为以后的cououtine指定dispatcher，或者产生不想要的side-effects, 因为coroutine中的一些操作必须立即执行。在一般的代码中不应该使用unconfined dispatcher。</p>
</blockquote>
<h2 id="调试-coroutines-和-threads">调试 Coroutines 和 Threads</h2>
<p>Coroutine可以在一个线程上暂停，在另一个线程上恢复。即使是同处一个Thread调度器，如果你没有特殊的工具，可能也很难弄清楚这个程序在做什么，在哪里做，什么时候做。</p>
<h3 id="用idea进行调试">用IDEA进行调试</h3>
<p>Kotlin插件的Coroutine调试器简化了在IntelliJ IDEA中调试coroutine的工作。</p>
<blockquote>
<p>调试器适用于1.3.8或更高版本的<code>kotlinx-coroutines-core</code></p>
</blockquote>
<p>在<strong>调试</strong>工具窗口中包含<strong>程序</strong>标签。在这个Tab中，你可以找到关于当前运行和暂停的程序的信息。这些程序按它们所运行的调度器进行分组。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/Kotlin/kotlinx.coroutines/master/docs/images/coroutine-debug-1.png" alt="Debugging coroutines" loading="lazy"></figure>
<p>使用coroutine调试器，你可以。</p>
<ul>
<li>检查每个coroutine的状态。</li>
<li>查看正在运行和暂停的coroutine的local变量和captured变量的值。</li>
<li>查看完整的coroutine创建栈，以及coroutine内部的调用栈。堆栈包括所有带有变量值的帧，甚至那些在标准调试过程中会丢失的帧。</li>
<li>获得一个完整的报告，其中包含每个程序的状态和它的堆栈。要获得它，在<strong>程序</strong>标签内点击右键，然后点击<strong>Get Coroutines Dump</strong>。</li>
</ul>
<p>要开始进行coroutine调试，你只需要设置断点并在调试模式下运行应用程序。</p>
<p>在 <a href="https://kotlinlang.org/docs/tutorials/coroutines/debug-coroutines-with-idea.html">教程</a>中了解更多关于coroutines调试的信息。</p>
<h3 id="使用日志进行调试">使用日志进行调试</h3>
<p>在没有Coroutine Debugger的情况下，调试应用程序的另一种方法是在每个日志语句中打印日志文件中的线程名称。这个功能被普遍日志框架支持。当使用coroutines时，单单是线程名称并不能提供太多的context 信息，为了使其更容易调试，<code>kotlinx.coroutines</code>包含了调试工具。</p>
<p>使用<code>-Dkotlinx.coroutines.debug</code>JVM选项运行以下代码。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun log(msg: String) = println(&quot;[${Thread.currentThread().name}] $msg&quot;)

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val a = async {
        log(&quot;I'm computing a piece of the answer&quot;)
        6
    }
    val b = async {
        log(&quot;I'm computing another piece of the answer&quot;)
        7
    }
    log(&quot;The answer is ${a.await() * b.await()}&quot;)
//sampleEnd    
}
</code></pre>
<p>上面包含三个coroutines程序。<code>runBlocking</code>中的主程序（#1）和两个计算延迟值<code>a</code>（#2）和<code>b</code>（#3）的程序。它们都是在<code>runBlocking</code>的context中执行的，并且被限制在<code>main</code>线程中。</p>
<p>这段代码的输出是</p>
<pre><code class="language-text">[main @coroutine#2] I'm computing a piece of the answer
[main @coroutine#3] I'm computing another piece of the answer
[main @coroutine#1] The answer is 42
</code></pre>
<p><code>log</code>函数在方括号中打印出线程的名称，你可以看到它是<code>main</code>线程，上面附加了当前执行的coroutine的标识。当调试模式开启时，这个标识符会分配给所有创建的coroutines。</p>
<blockquote>
<p>当JVM以<code>-ea</code>选项运行时，调试模式也被打开。你可以在 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-d-e-b-u-g_-p-r-o-p-e-r-t-y_-n-a-m-e.html">DEBUG_PROPERTY_NAME</a> 阅读更多关于调试设施的信息</p>
</blockquote>
<h2 id="threads之间的跳转">Threads之间的跳转</h2>
<p>使用<code>-Dkotlinx.coroutines.debug</code>JVM选项运行以下代码（见<a href="#debugging-coroutines-and-threads">debug</a>）</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun log(msg: String) = println(&quot;[${Thread.currentThread().name}] $msg&quot;)

fun main() {
//sampleStart
    newSingleThreadContext(&quot;Ctx1&quot;).use { ctx1 -&gt;
        newSingleThreadContext(&quot;Ctx2&quot;).use { ctx2 -&gt;
            runBlocking(ctx1) {
                log(&quot;Started in ctx1&quot;)
                withContext(ctx2) {
                    log(&quot;Working in ctx2&quot;)
                }
                log(&quot;Back to ctx1&quot;)
            }
        }
    }
//sampleEnd    
}
</code></pre>
<p>上面演示了几种新特性。一个是使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a>明确指定的context，另一个是使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html">withContext</a>函数来改变一个coroutine的context，同时仍然保持在同一个coroutine中，你可以在下面的输出中看到。</p>
<pre><code class="language-text">[Ctx1 @coroutine#1] Started in ctx1
[Ctx2 @coroutine#1] Working in ctx2
[Ctx1 @coroutine#1] Back to ctx1
</code></pre>
<p>请注意，这个例子也使用了Kotlin标准库中的<code>use</code>函数，用来在不再需要时释放出创建出来的Thread [newSingleThreadContext]（https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html）创建的线程。</p>
<h2 id="context中的job">Context中的Job</h2>
<p>Coroutine的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>是其context的一部分，你可以使用<code>coroutineContext[Job]</code>表达式拿到。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    println(&quot;My job is ${coroutineContext[Job]}&quot;)
//sampleEnd    
}
</code></pre>
<p>在<a href="#debugging-coroutines-and-threads">调试模式</a>下，它的输出结果是这样的。</p>
<pre><code>My job is &quot;coroutine#1&quot;:BlockingCoroutine{Active}@6d311334
</code></pre>
<p>注意，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>中的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html">isActive</a>只是<code>coroutineContext[Job]?.isActive == true</code>的shortcut而已。</p>
<h2 id="coroutine的层级结构">Coroutine的层级结构</h2>
<p>当一个coroutine在另一个coroutine的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>中启动时，它通过<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/coroutine-context.html">CoroutineScope.coroutineContext</a>继承其context，新建的coroutine中的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>成为父级coroutine的Job的child。当父级coroutine被取消时，它下面所有child coroutine也会被递归地取消。</p>
<p>然而，这种父子关系可以通过以下两种方式之一显式声明推翻。</p>
<ol>
<li>当启动一个cououtine时明确指定了一个不同的context（例如，<code>GlobalScope.launch</code>），那么它就不会从父级context继承<code>Job</code>。</li>
<li>当一个不同的<code>Job</code>对象被传递作为新的coroutine的context时（如下面的例子所示），那么它将覆盖父级context中的<code>Job</code>。</li>
</ol>
<p>在这两种情况下，启动的coroutine都是独立运行，不与它所启动的context相联系。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    // launch a coroutine to process some kind of incoming request
    val request = launch {
        // it spawns two other jobs
        launch(Job()) { 
            println(&quot;job1: I run in my own Job and execute independently!&quot;)
            delay(1000)
            println(&quot;job1: I am not affected by cancellation of the request&quot;)
        }
        // and the other inherits the parent context
        launch {
            delay(100)
            println(&quot;job2: I am a child of the request coroutine&quot;)
            delay(1000)
            println(&quot;job2: I will not execute this line if my parent request is cancelled&quot;)
        }
    }
    delay(500)
    request.cancel() // cancel processing of the request
    delay(1000) // delay a second to see what happens
    println(&quot;main: Who has survived request cancellation?&quot;)
//sampleEnd
}
</code></pre>
<p>这段代码的输出是：</p>
<pre><code class="language-text">job1: I run in my own Job and execute independently!
job2: I am a child of the request coroutine
job1: I am not affected by cancellation of the request
main: Who has survived request cancellation?
</code></pre>
<h2 id="父级coroutine的职责">父级Coroutine的职责</h2>
<p>父级coroutine总是等待其所有子级coroutine的执行完成。父级coroutine不必关心它下面子程序的启动，也不必使用子程序们的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html">Job.join</a>来等待它们结束。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    // launch a coroutine to process some kind of incoming request
    val request = launch {
        repeat(3) { i -&gt; // launch a few children jobs
            launch  {
                delay((i + 1) * 200L) // variable delay 200ms, 400ms, 600ms
                println(&quot;Coroutine $i is done&quot;)
            }
        }
        println(&quot;request: I'm done and I don't explicitly join my children that are still active&quot;)
    }
    request.join() // wait for completion of the request, including all its children
    println(&quot;Now processing of the request is complete&quot;)
//sampleEnd
}
</code></pre>
<p>这段代码的输出是：</p>
<pre><code class="language-text">request: I'm done and I don't explicitly join my children that are still active
Coroutine 0 is done
Coroutine 1 is done
Coroutine 2 is done
Now processing of the request is complete
</code></pre>
<h2 id="为调试中的coroutines-命名">为调试中的coroutines 命名</h2>
<p>当你使用coroutine时打印日志，为coroutine分配不同id有助于把相同coroutine的日志记录关联起来。然而，当一个coroutine与处理一个特定的请求或做一些后台任务 联系在一起时，为了调试的目的，最好先显式地命名它。在context 中的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-name/index.html">CoroutineName</a> 作用与线程名相同。当<a href="#debugging-coroutines-and-threads">debugging mode</a>开启时，它被包含在执行这个coroutine的线程名称中。</p>
<p>下面的例子演示下这个概念。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun log(msg: String) = println(&quot;[${Thread.currentThread().name}] $msg&quot;)

fun main() = runBlocking(CoroutineName(&quot;main&quot;)) {
//sampleStart
    log(&quot;Started main coroutine&quot;)
    // run two background value computations
    val v1 = async(CoroutineName(&quot;v1coroutine&quot;)) {
        delay(500)
        log(&quot;Computing v1&quot;)
        252
    }
    val v2 = async(CoroutineName(&quot;v2coroutine&quot;)) {
        delay(1000)
        log(&quot;Computing v2&quot;)
        6
    }
    log(&quot;The answer for v1 / v2 = ${v1.await() / v2.await()}&quot;)
//sampleEnd    
}
</code></pre>
<p>使用<code>-Dkotlinx.coroutines.debug</code>JVM选项，它产生下面的输出。</p>
<pre><code class="language-text">[main @main#1] Started main coroutine
[main @v1coroutine#2] Computing v1
[main @v2coroutine#3] Computing v2
[main @main#1] The answer for v1 / v2 = 42
</code></pre>
<h2 id="结合context的变量">结合context的变量</h2>
<p>有时我们需要在coroutine中的context定义多个变量。我们可以使用<code>+</code>操作符来实现这一点。例如，我们可以同时显式指定调度器和coroutine的名字后再启动coroutine。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    launch(Dispatchers.Default + CoroutineName(&quot;test&quot;)) {
        println(&quot;I'm working in thread ${Thread.currentThread().name}&quot;)
    }
//sampleEnd    
}
</code></pre>
<p>使用<code>-Dkotlinx.coroutines.debug</code>JVM选项，它产生下面的输出。</p>
<pre><code class="language-text">I'm working in thread DefaultDispatcher-worker-1 @test#2
</code></pre>
<h2 id="coroutine-作用域">Coroutine 作用域</h2>
<p>让我们把关于contexts、子coroutine和job的几个概念放在一起讨论下。假设我们的应用程序有一个关于生命周期的对象，但这个对象并不是一个coroutine。例如，我们正在编写一个Android应用程序，并在一个Android Activity的context中启动多个coroutine来执行异步操作来获取更新数据，做动画特效，等等。当Activity被销毁时，所有这些coroutine都必须被取消，以避免内存泄漏。当然，我们可以绑定Activity的生命周期，手动操作context和job来管理coroutine。在此之外 <code>kotlinx.coroutines</code>还提供了一个抽象的封装 -- <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>。你应该已经熟悉了 <em>CoroutineScope</em> ，因为所有的coroutine构建器都是它的扩展。</p>
<p>我们通过创建<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>的实例来管理我们coroutine的生命周期，该实例与Activity的生命周期相绑定。一个 <code>CoroutineScope</code> 实例可以由<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html">CoroutineScope()</a>或<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html">MainScope()</a> 创建。前者创建了一个通用的context，而后者为UI应用程序创建了一个作用域，并使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html">Dispatchers.Main</a>作为默认的dispatcher。</p>
<pre><code class="language-kotlin">class Activity {
    private val mainScope = MainScope()
    
    fun destroy() {
        mainScope.cancel()
    }
    // to be continued ...
</code></pre>
<p>现在，我们在这个 &quot;Activity &quot;的范围内，可以通过 <code>scope</code>来启动coroutines。在这个demo中，我们启动了十个延迟不同时间的coroutines。</p>
<pre><code class="language-kotlin">    // class Activity continues
    fun doSomething() {
        // launch ten coroutines for a demo, each working for a different time
        repeat(10) { i -&gt;
            mainScope.launch {
                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc
                println(&quot;Coroutine $i is done&quot;)
            }
        }
    }
} // class Activity ends
</code></pre>
<p>在我们的main函数中，我们创建了Activity，调用了 <code>doSomething</code>函数，并在500ms后销毁Activity。这就取消了所有从<code>doSomething</code>启动的coroutines。我们会发现，在Activity销毁后，即使我们再等一会儿，也不会有更多的消息被打印出来。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

class Activity {
    private val mainScope = CoroutineScope(Dispatchers.Default) // use Default for test purposes
    
    fun destroy() {
        mainScope.cancel()
    }

    fun doSomething() {
        // launch ten coroutines for a demo, each working for a different time
        repeat(10) { i -&gt;
            mainScope.launch {
                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc
                println(&quot;Coroutine $i is done&quot;)
            }
        }
    }
} // class Activity ends

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val activity = Activity()
    activity.doSomething() // run test function
    println(&quot;Launched coroutines&quot;)
    delay(500L) // delay for half a second
    println(&quot;Destroying activity!&quot;)
    activity.destroy() // cancels all coroutines
    delay(1000) // visually confirm that they don't work
//sampleEnd    
}
</code></pre>
<p>这段代码的输出是</p>
<pre><code class="language-text">Launched coroutines
Coroutine 0 is done
Coroutine 1 is done
Destroying activity!
</code></pre>
<p>正如你所看到的，只有前两个coroutines打印了一条消息，其他的都被<code>Activity.destroy()</code>中的一次<code>job.cancel()</code>调用取消了。</p>
<blockquote>
<p>注意，Android在所有entities的lifecycle中，都有对coroutine scope的优先支持。参见<a href="https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope">相应的文档</a>。</p>
</blockquote>
<h3 id="thread局部数据">Thread局部数据</h3>
<p>有时，如果可以将一些Thread本地的数据传递给coroutines或在coroutines之间传递，那么就很方便了。然而，由于coroutines没有被绑定到任何特定的Thread，如果手动处理绑定的话将相当十分笨拙。</p>
<p>针对 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html">ThreadLocal</a>，在这里我们可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/as-context-element.html">asContextElement</a>扩展函数来实现。它创建一个额外的context，用来记录给定的<code>ThreadLocal</code>的值，并在每次coroutine切换context时恢复它。</p>
<p>看下面的演示:</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

val threadLocal = ThreadLocal&lt;String?&gt;() // declare thread-local variable

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    threadLocal.set(&quot;main&quot;)
    println(&quot;Pre-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'&quot;)
    val job = launch(Dispatchers.Default + threadLocal.asContextElement(value = &quot;launch&quot;)) {
        println(&quot;Launch start, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'&quot;)
        yield()
        println(&quot;After yield, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'&quot;)
    }
    job.join()
    println(&quot;Post-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'&quot;)
//sampleEnd    
}
</code></pre>
<p>在这个例子中，我们使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html">Dispatchers.Default</a>在后台线程池中启动了一个新的coroutine，因此它在与线程池不同的线程上工作，但它依然可以访问通过<code>threadLocal.asContextElement(value = &quot;launch&quot;)</code>定义的Thread局部变量的值，不管coroutine在哪个Thread上执行。</p>
<p>因此调试下输出是:</p>
<pre><code class="language-text">Pre-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'
Launch start, current thread: Thread[DefaultDispatcher-worker-1 @coroutine#2,5,main], thread local value: 'launch'
After yield, current thread: Thread[DefaultDispatcher-worker-2 @coroutine#2,5,main], thread local value: 'launch'
Post-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'
</code></pre>
<p>我们很容易忘记设置相应的context变量。如果运行coroutine程序的Thread不同，那么从coroutine访问的线程本地变量可能会有一个意外的值。为了避免这种情况，建议使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/ensure-present.html">ensurePresent</a>方法，并在不适当的调用中 <em>fail-fast</em> 。</p>
<p><code>ThreadLocal</code>具有优先的支持，可以任何<code>kotlinx.coroutines</code>提供的接口中使用。但它有一个重要的限制：当thread-local被改变时，新的值不会传播给coroutine调用者（因为context变量不能跟踪<code>ThreadLocal</code>对象的访问），更新的值会在下一次suspend时丢失。当然你可以使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html">withContext</a>来更新coroutine中thread-local的值，更多细节见<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/as-context-element.html">asContextElement</a>。</p>
<p>另外，一个值可以存储在一个可变的容器中，如<code>class Counter(var i: Int)</code>，它又被存储在线程局部变量中。然而，在这种情况下，你要对这个变量会被进行潜在的并发修改进行管理。</p>
<p>对于高级用法，例如与日志MDC、context事务性，或其他内部使用thread-locals传递数据的库，请参阅对应实现的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-thread-context-element/index.html">ThreadContextElement</a>接口的文档。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin Coroutine Part 3. Composing suspending functions]]></title>
        <id>https://waltcow.github.io/post/kotlin-coroutine-part-3-composing-suspending-functions/</id>
        <link href="https://waltcow.github.io/post/kotlin-coroutine-part-3-composing-suspending-functions/">
        </link>
        <updated>2021-07-27T09:42:50.000Z</updated>
        <summary type="html"><![CDATA[<p>这一节将介绍各种构建suspend函数的方法</p>
]]></summary>
        <content type="html"><![CDATA[<p>这一节将介绍各种构建suspend函数的方法</p>
<!-- more -->
<h2 id="默认的串行执行">默认的串行执行</h2>
<p>假设我们预先定义了两个suspend函数，它们运行着一些比如远程服务调用或计算的逻辑。我们只是假装它们是有用的，在这个例子中，每个函数只是延迟一秒钟作为模拟。</p>
<pre><code class="language-kotlin">suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}
</code></pre>
<p>如果我们需要它们依次被调用 -- 首先是<code>doSomethingUsefulOne</code>，然后是<code>doSomethingUsefulTwo</code>，并计算它们的结果之和，我们该怎么做？在真实场景中，如果我们用第一个函数的返回结果来决定第二个函数是否需要调用或如何调用，我们就会这样做。</p>
<p>我们按正常的顺序调用，因为coroutine中的代码，就像普通代码一样，默认是顺序执行的。下面的例子通过测量两个suspend函数的总执行时间作为演示。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val time = measureTimeMillis {
        val one = doSomethingUsefulOne()
        val two = doSomethingUsefulTwo()
        println(&quot;The answer is ${one + two}&quot;)
    }
    println(&quot;Completed in $time ms&quot;)
//sampleEnd    
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}
</code></pre>
<p>运行的输出如下：</p>
<pre><code class="language-text">The answer is 42
Completed in 2017 ms
</code></pre>
<h2 id="使用async进行并发">使用async进行并发</h2>
<p>如果<code>doSomethingUsefulOne</code>和<code>doSomethingUsefulTwo</code>的调用之间没有依赖关系，而我们想同时进行这两个操作来更快地得到答案，怎么办？这就是<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a>发挥作用的地方。</p>
<p>从概念上讲，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a>就像<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a>一样。它启动了一个单独的coroutine，这是一个轻量级的线程，与所有其他的coroutine同时工作。不同的是，<code>launch</code>返回一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>，并且不携带任何结果值，而<code>async</code>返回一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/index.html">Deferred</a>--一个轻量级的非阻塞Future，代表一个Promise，以后提供一个结果。你可以在一个Deferred上使用<code>.await()</code>来获得它的最终结果，但是<code>Deferred</code>也是一个<code>Job</code>，所以你可以在需要时取消它。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val time = measureTimeMillis {
        val one = async { doSomethingUsefulOne() }
        val two = async { doSomethingUsefulTwo() }
        println(&quot;The answer is ${one.await() + two.await()}&quot;)
    }
    println(&quot;Completed in $time ms&quot;)
//sampleEnd    
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}

</code></pre>
<p>运行的输出如下：</p>
<pre><code class="language-text">The answer is 42
Completed in 1017 ms
</code></pre>
<p>这是两倍的速度，因为这两个coroutines是同时执行的。请注意，coroutines的并发性总是显式的。</p>
<h2 id="async的懒启动">async的懒启动</h2>
<p>另外，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a>可以通过将其<code>start</code>参数设置为<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y/index.html">CoroutineStart.LAZY</a>而变成懒启动。在这种模式下，只有当<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html">await</a>需要它的结果时，或者它的<code>Job</code>的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html">start</a>函数被调用时，它才会启动coroutine。运行下面的例子。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val time = measureTimeMillis {
        val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }
        val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }
        // some computation
        one.start() // start the first one
        two.start() // start the second one
        println(&quot;The answer is ${one.await() + two.await()}&quot;)
    }
    println(&quot;Completed in $time ms&quot;)
//sampleEnd    
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}
</code></pre>
<p>运行的输出如下：</p>
<pre><code class="language-text">The answer is 42
Completed in 1017 ms
</code></pre>
<p>这里定义了两个coroutines，但没有像前面的例子那样执行，而是通过调用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html">start</a>，将具体何时开始执行的控制权交给程序员。我们首先启动 &quot;one&quot;，然后启动 &quot;two&quot;，然后等待各个coroutines的完成。</p>
<p>请注意，如果我们只是在<code>println</code>中调用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html">await</a>，而不先在单个coroutine上调用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html">start</a>，这将导致顺序执行的，因为<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html">await</a>启动coroutine执行并等待其结束，这不是懒启动的预期行为。<code>async(start = CoroutineStart.LAZY)</code>的用例是在计算值涉及暂停功能的情况下替代标准<code>lazy</code>函数。</p>
<h2 id="async风格的函数">async风格的函数</h2>
<p>我们可以定义异步风格的函数，使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> 作为coroutine构建器来异步调用<code>doSomethingUsefulOne</code>和<code>doSomethingUsefulTwo</code>，配合<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html">GlobalScope</a>的引用来选择退出结构化并发。我们一般会用&quot;......Async &quot;作为后缀来命名这类函数，以强调它们使用异步方式执行，人们需要使用它返回的延迟值来获取结果。</p>
<blockquote>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html">GlobalScope</a>是一个精致的API，将在下面解释，你必须显式地选择使用<code>GlobalScope</code>与<code>@OptIn(DelicateCoroutinesApi::class)</code></p>
</blockquote>
<pre><code class="language-kotlin">// The result type of somethingUsefulOneAsync is Deferred&lt;Int&gt;
@OptIn(DelicateCoroutinesApi::class)
fun somethingUsefulOneAsync() = GlobalScope.async {
    doSomethingUsefulOne()
}

// The result type of somethingUsefulTwoAsync is Deferred&lt;Int&gt;
@OptIn(DelicateCoroutinesApi::class)
fun somethingUsefulTwoAsync() = GlobalScope.async {
    doSomethingUsefulTwo()
}
</code></pre>
<p>请注意，这些<code>xxxAsync</code>函数不是<em>suspending</em>函数。它们可以从任何地方使用。然而，使用它们意味着是异步<em>并发</em> 执行。</p>
<p>下面的例子介绍它们如何在coroutine之外的使用。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlin.system.*

//sampleStart
// note that we don't have `runBlocking` to the right of `main` in this example
fun main() {
    val time = measureTimeMillis {
        // we can initiate async actions outside of a coroutine
        val one = somethingUsefulOneAsync()
        val two = somethingUsefulTwoAsync()
        // but waiting for a result must involve either suspending or blocking.
        // here we use `runBlocking { ... }` to block the main thread while waiting for the result
        runBlocking {
            println(&quot;The answer is ${one.await() + two.await()}&quot;)
        }
    }
    println(&quot;Completed in $time ms&quot;)
}
//sampleEnd

@OptIn(DelicateCoroutinesApi::class)
fun somethingUsefulOneAsync() = GlobalScope.async {
    doSomethingUsefulOne()
}

@OptIn(DelicateCoroutinesApi::class)
fun somethingUsefulTwoAsync() = GlobalScope.async {
    doSomethingUsefulTwo()
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>The answer is 42
Completed in 1175 ms
</code></pre>
<blockquote>
<p>这种异步函数的编程风格在这里提出只是为了说明问题，因为它在其他编程语言中是一种比较流行的风格。但在Kotlin coroutines中使用这种风格是<strong>强烈反对</strong>的，原因如下</p>
</blockquote>
<p>设想一下，如果在<code>val one = somethingUsefulOneAsync()</code> 和 <code>one.await()</code>表达式之间，代码中出现了一些逻辑错误，程序抛出了一个异常，程序正在进行的操作就会中止。通常情况下，程序的全局错误处理会捕获这个异常，并报告这个错误，但程序可以继续进行其他操作。然而，在这里我们看到<code>somethingUsefulOneAsync</code>仍然在后台运行，尽管启动它的操作被中止了。这个问题在结构化并发中不会发生，如下节所示。</p>
<h2 id="使用async进行-结构化并发">使用async进行 结构化并发</h2>
<p>让我们以<a href="#concurrent-using-async">Concurrent using async</a>为例，提取一个函数来并发执行<code>doSomethingUsefulOne</code>和<code>doSomethingUsefulTwo</code>并返回其结果的总和。因为<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> coroutine builder是CoroutineScope](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html)的扩展，我们可以在作用域中使用它。</p>
<pre><code class="language-kotlin">suspend fun concurrentSum(): Int = coroutineScope {
    val one = async { doSomethingUsefulOne() }
    val two = async { doSomethingUsefulTwo() }
    one.await() + two.await()
}
</code></pre>
<p>这样，如果 <code>concurrentSum</code>函数的代码出了问题，它抛出了一个异常，所有在其范围内启动的程序都会被取消。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    val time = measureTimeMillis {
        println(&quot;The answer is ${concurrentSum()}&quot;)
    }
    println(&quot;Completed in $time ms&quot;)
//sampleEnd    
}

suspend fun concurrentSum(): Int = coroutineScope {
    val one = async { doSomethingUsefulOne() }
    val two = async { doSomethingUsefulTwo() }
    one.await() + two.await()
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // pretend we are doing something useful here
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // pretend we are doing something useful here, too
    return 29
}
</code></pre>
<p>从上述 <code>main</code>函数的输出中可以看出，两个操作依然是并发执行。</p>
<pre><code class="language-text">The answer is 42
Completed in 1017 ms
</code></pre>
<p>取消总是通过coroutines的按层次传播的。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking&lt;Unit&gt; {
    try {
        failedConcurrentSum()
    } catch(e: ArithmeticException) {
        println(&quot;Computation failed with ArithmeticException&quot;)
    }
}

suspend fun failedConcurrentSum(): Int = coroutineScope {
    val one = async&lt;Int&gt; { 
        try {
            delay(Long.MAX_VALUE) // Emulates very long computation
            42
        } finally {
            println(&quot;First child was cancelled&quot;)
        }
    }
    val two = async&lt;Int&gt; { 
        println(&quot;Second child throws an exception&quot;)
        throw ArithmeticException()
    }
    one.await() + two.await()
}

</code></pre>
<p>请注意第一个<code>async</code> 和等待中的父类是如何被<code>two</code>失败而被取消的。</p>
<pre><code class="language-text">Second child throws an exception
First child was cancelled
Computation failed with ArithmeticException
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin Coroutine Part 2. Cancellation and timeouts]]></title>
        <id>https://waltcow.github.io/post/kotlin-coroutine-part-2-cancellation-and-timeouts/</id>
        <link href="https://waltcow.github.io/post/kotlin-coroutine-part-2-cancellation-and-timeouts/">
        </link>
        <updated>2021-07-27T08:32:32.000Z</updated>
        <summary type="html"><![CDATA[<p>本文简单介绍一下 Kotlin Coroutine的取消和超时处理</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文简单介绍一下 Kotlin Coroutine的取消和超时处理</p>
<!-- more -->
<h1 id="kotlin-coroutine-part-2-cancellation-and-timeouts">Kotlin Coroutine Part 2. Cancellation and timeouts</h1>
<p>在一个长时间运行的应用程序中，你可能需要对运行在后台的coroutines进行细粒度的控制。例如，用户可能已经关闭了一个正在运行着的coroutine页面，现在不再需要其结果了，可以取消其操作。<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a>函数返回一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>，可以用来取消运行中的coroutine。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch {
        repeat(1000) { i -&gt;
            println(&quot;job: I'm sleeping $i ...&quot;)
            delay(500L)
        }
    }
    delay(1300L) // delay a bit
    println(&quot;main: I'm tired of waiting!&quot;)
    job.cancel() // cancels the job
    job.join() // waits for job's completion 
    println(&quot;main: Now I can quit.&quot;)
//sampleEnd    
}
</code></pre>
<p>它的输出结果如下</p>
<pre><code class="language-text">job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
main: Now I can quit.
</code></pre>
<p>只要main调用<code>job.cancel</code>，我们就看不到另一个coroutine的任何输出，因为它被取消了。还有一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>的扩展函数<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel-and-join.html">cancelAndJoin</a>，结合了<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel.html">cancel</a>和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html">join</a>的调用。</p>
<h2 id="取消是相互协同的">取消是相互协同的</h2>
<p>Coroutine的取消是<em>相互协同的</em>。Coroutine代码必须在相互协同下才能被取消。<code>kotlinx.coroutines</code>中所有的suspend函数都是<em>可取消的</em>。它们会检查Coroutine程序的取消，并在取消时抛出<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a>。然而，如果一个Coroutine在计算工作中，并且没有检查取消，那么它就不能被取消，就像下面的例子所示。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val startTime = System.currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (i &lt; 5) { // computation loop, just wastes CPU
            // print a message twice a second
            if (System.currentTimeMillis() &gt;= nextPrintTime) {
                println(&quot;job: I'm sleeping ${i++} ...&quot;)
                nextPrintTime += 500L
            }
        }
    }
    delay(1300L) // delay a bit
    println(&quot;main: I'm tired of waiting!&quot;)
    job.cancelAndJoin() // cancels the job and waits for its completion
    println(&quot;main: Now I can quit.&quot;)
//sampleEnd    
}

</code></pre>
<p>运行结果如下：</p>
<pre><code>job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
job: I'm sleeping 3 ...
job: I'm sleeping 4 ...
main: Now I can quit.

</code></pre>
<p>运行上面程序可以看到，即使在job被取消后，仍然继续打印 &quot;I'm sleeping&quot;，直到 job在反复执行5次后才完成。</p>
<h2 id="让正在运行中代码可以取消">让正在运行中代码可以取消</h2>
<p>有两种方法可以取消正在运行代码。第一种是周期性地调用一个检查取消的suspend函数。譬如使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html">yield</a>函数是个选择。另一种是显式地检查取消的状态。让我们试试后一种方法。</p>
<p>用<code>while (isActive)</code>替换前面例子中的<code>while (i &lt; 5)</code>，然后重新运行它。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val startTime = System.currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (isActive) { // cancellable computation loop
            // print a message twice a second
            if (System.currentTimeMillis() &gt;= nextPrintTime) {
                println(&quot;job: I'm sleeping ${i++} ...&quot;)
                nextPrintTime += 500L
            }
        }
    }
    delay(1300L) // delay a bit
    println(&quot;main: I'm tired of waiting!&quot;)
    job.cancelAndJoin() // cancels the job and waits for its completion
    println(&quot;main: Now I can quit.&quot;)
//sampleEnd    
}
</code></pre>
<p>运行结果：</p>
<pre><code>job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
main: Now I can quit.
</code></pre>
<p>正如你所看到的，现在这个循环被取消了。<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html">isActive</a>是通过<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>对象在coroutine内部可用的一个扩展属性。</p>
<h2 id="用-finally关闭占用资源">用 <code>finally</code>关闭占用资源</h2>
<p>可取消的暂停函数在取消时抛出<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a>，可以用常规方式处理。例如，<code>try {...} finally {...}</code>表达式和使用Kotlin的<code>use</code>函数，在一个coroutine被取消时正常执行它们的最终处理动作。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch {
        try {
            repeat(1000) { i -&gt;
                println(&quot;job: I'm sleeping $i ...&quot;)
                delay(500L)
            }
        } finally {
            println(&quot;job: I'm running finally&quot;)
        }
    }
    delay(1300L) // delay a bit
    println(&quot;main: I'm tired of waiting!&quot;)
    job.cancelAndJoin() // cancels the job and waits for its completion
    println(&quot;main: Now I can quit.&quot;)
//sampleEnd    
}

</code></pre>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html">join</a>和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel-and-join.html">cancelAndJoin</a>都会等待所有的终结动作完成，所以上面的例子会产生以下输出</p>
<pre><code class="language-text">job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
job: I'm running finally
main: Now I can quit.
</code></pre>
<h2 id="运行不可取消的程序块">运行不可取消的程序块</h2>
<p>在前面例子中，当运行代码的coroutine被取消的情况下， 任何试图在 <code>finally</code>块中使用suspend函数的行为都会导致<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a>。通常情况下这并不影响，因为所有处理得当的关闭操作（关闭File读写、取消Job或关闭任何类型的channel）通常都是无阻塞的，不涉及任何suspend函数。然而，在极少数情况下，当你需要在一个已取消的程序中暂停时，你可以使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html">withContext</a>函数和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-non-cancellable/index.html">NonCancellable</a> 的context 将相应的代码包裹在<code>withContext(NonCancellable) {...}</code>中，正如下面的例子所示。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch {
        try {
            repeat(1000) { i -&gt;
                println(&quot;job: I'm sleeping $i ...&quot;)
                delay(500L)
            }
        } finally {
            withContext(NonCancellable) {
                println(&quot;job: I'm running finally&quot;)
                delay(1000L)
                println(&quot;job: And I've just delayed for 1 sec because I'm non-cancellable&quot;)
            }
        }
    }
    delay(1300L) // delay a bit
    println(&quot;main: I'm tired of waiting!&quot;)
    job.cancelAndJoin() // cancels the job and waits for its completion
    println(&quot;main: Now I can quit.&quot;)
//sampleEnd    
}
</code></pre>
<p>代码运行结果</p>
<pre><code>job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
job: I'm running finally
job: And I've just delayed for 1 sec because I'm non-cancellable
main: Now I can quit.

</code></pre>
<h2 id="超时处理">超时处理</h2>
<p>取消一个执行中的coroutine，最常见原因是因为它的执行时间已经超时了。虽然你可以手动拿到相应的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>的引用，并在延迟一会儿后再启动一个单独的coroutine来取消那个job，但这里推荐用一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout</a>函数处理。请看下面的例子。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    withTimeout(1300L) {
        repeat(1000) { i -&gt;
            println(&quot;I'm sleeping $i ...&quot;)
            delay(500L)
        }
    }
//sampleEnd
}
</code></pre>
<p>输出结果如下:</p>
<pre><code class="language-text">I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
Exception in thread &quot;main&quot; kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms
</code></pre>
<p>由<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout</a>抛出的<code>TimeoutCancellationException</code>是<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a>的一个子类。我们以前没有在控制台看到它的堆栈信息。这是因为在一个被取消的循环程序里面，<code>CancellationException</code>被认为是循环程序结束的一个合理原因。然而，在这个例子中，我们在<code>main</code>函数中使用了`withTimeout'。</p>
<p>由于取消只是一个异常，所有的资源都以正常的方式关闭。如果你需要在任何一种超时情况下专门做一些额外的动作，你可以用<code>try {...} catch (e: TimeoutCancellationException) {...}</code>块来包装处理超时的代码，或者使用<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout-or-null.html">withTimeoutOrNull</a>函数，它与<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout</a>类似，但不同是它会在超时后会返回<code>null</code>而不是抛出一个异常。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val result = withTimeoutOrNull(1300L) {
        repeat(1000) { i -&gt;
            println(&quot;I'm sleeping $i ...&quot;)
            delay(500L)
        }
        &quot;Done&quot; // will get cancelled before it produces this result
    }
    println(&quot;Result is $result&quot;)
//sampleEnd
}
</code></pre>
<p>输出结果如下:</p>
<pre><code class="language-text">I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
Result is null
</code></pre>
<h2 id="异步操作的超时处理和资源管理">异步操作的超时处理和资源管理</h2>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout</a>中的超时事件对于在其块中运行的代码来说是异步的，可能在任何时候发生，甚至在从超时代码块内部返回之前。如果你在区块内打开或获取一些需要在区块外关闭或释放的资源，请牢记这一点。</p>
<p>例如，这里我们用<code>Resource</code>类来模仿一个可关闭的资源，它只通过增加<code>acquired</code>计数器和从<code>close</code>函数中减去这个计数器来跟踪它被创建的次数。让我们用很小的超时来运行大量的循环程序，尝试在延迟一段时间后从<code>withTimeout</code>块内部获取这个资源，并从外部释放它。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

//sampleStart
var acquired = 0

class Resource {
    init { acquired++ } // Acquire the resource
    fun close() { acquired-- } // Release the resource
}

fun main() {
    runBlocking {
        repeat(100_000) { // Launch 100K coroutines
            launch { 
                val resource = withTimeout(60) { // Timeout of 60 ms
                    delay(50) // Delay for 50 ms
                    Resource() // Acquire a resource and return it from withTimeout block     
                }
                resource.close() // Release the resource
            }
        }
    }
    // Outside of runBlocking all coroutines have completed
    println(acquired) // Print the number of resources still acquired
}
//sampleEnd
</code></pre>
<p>如果你运行上面的代码，你会发现它并不总是打印0，尽管这可能取决于你的机器的时间，你可能需要在这个例子中调整超时时间，以真正看到非0值。</p>
<blockquote>
<p>注意，在这里从100K Coroutine中增加和减少<code>acquired</code>计数器是完全安全的，因为它总是发生在同一个主线程中。关于这一点，我们将在下一章的coroutine上下文中作进一步解释。</p>
</blockquote>
<p>为了解决这个问题，你可以在变量中存储对资源的引用，而不是从<code>withTimeout</code> 块中返回它</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

var acquired = 0

class Resource {
    init { acquired++ } // Acquire the resource
    fun close() { acquired-- } // Release the resource
}

fun main() {
//sampleStart
    runBlocking {
        repeat(100_000) { // Launch 100K coroutines
            launch { 
                var resource: Resource? = null // Not acquired yet
                try {
                    withTimeout(60) { // Timeout of 60 ms
                        delay(50) // Delay for 50 ms
                        resource = Resource() // Store a resource to the variable if acquired      
                    }
                    // We can do something else with the resource here
                } finally {  
                    resource?.close() // Release the resource if it was acquired
                }
            }
        }
    }
    // Outside of runBlocking all coroutines have completed
    println(acquired) // Print the number of resources still acquired
//sampleEnd
}
</code></pre>
<p>这个例子总是打印出零。资源不会泄漏。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Kotlin Coroutine Part 1. Basic]]></title>
        <id>https://waltcow.github.io/post/ Kotlin Coroutine Part 1. Basic/</id>
        <link href="https://waltcow.github.io/post/ Kotlin Coroutine Part 1. Basic/">
        </link>
        <updated>2021-07-22T06:56:28.000Z</updated>
        <summary type="html"><![CDATA[<p>kotlinx.coroutines 作为一个由Jetbrains开发的 Coroutine 管理库，它包含了很多高级的操作coroutines的API, 本文介绍一些基础用法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>kotlinx.coroutines 作为一个由Jetbrains开发的 Coroutine 管理库，它包含了很多高级的操作coroutines的API, 本文介绍一些基础用法。</p>
<!-- more -->
<h1 id="kotlin-coroutine">Kotlin Coroutine</h1>
<p>Kotlin 语言中 <em>async</em> 和 <em>await</em> 并不是保留的关键词， 它在标准库只提供了有限的low-level 的API，让其生态的库自己去管理Coroutine编程控制相关的细节。 另一方面，相对于其他语言中的Future和Promise，Kotlin提出了Suspend 的概念抽象让异步编程变得相对安全和更少出错。</p>
<p><em>kotlinx.coroutines</em> 作为一个由Jetbrains开发的 Coroutine 管理库，它包含了很多高级的操作coroutines的API，譬如 <em>launch</em> 和 <em>async</em> 还有其他。</p>
<p>接下来阐述coroutine的基本概念</p>
<p>Coroutine 是可suspend计算的实例, 概念上它和线程非常的相似，它们都会接收一段块状代码，并与剩下的代码同时执行</p>
<p>但值得注意的是，coroutine 是不和任何特定的线程绑定在一起的，它可能会在一条线程上执行的，而在另外一条上恢复。</p>
<p>Coroutines 可以被想象为轻量化的线程，但它们之间有着重要的区别，以至于在真实的使用场景中和线程有着明显的不同</p>
<p>下面代码作为首个coroutine的例子作为阐述</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

//sampleStart
fun main() = runBlocking { // this: CoroutineScope
    launch { // launch a new coroutine and continue
        delay(1000L) // non-blocking delay for 1 second (default time unit is ms)
        println(&quot;World!&quot;) // print after delay
    }
    println(&quot;Hello&quot;) // main coroutine continues while a previous one is delayed
}
//sampleEnd
</code></pre>
<p>打印的结果</p>
<pre><code>Hello
World!
</code></pre>
<p>下面逐行分析代码的执行过程</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a>  是 coroutine构造器. 它另开了新的协程，同时执行剩下的代码，这都是同时独立的执行，所以 <strong>Hello</strong> 会第一个被打印出来</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a>  是一个特殊 <em>suspending function</em>. 它会在coroutine上 <em>suspends</em> 一段时间。 coroutine在暂停的同时并不会对阻塞它所处在的线程 ，同时允许其他的coroutine 在它当前的线程中执行它们的代码。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a>  另一个 coroutine的构造器，它可以让协程的代码和外界有了桥接和联系，以main() 作为入口。在一系列的coroutine外面会被runBlocking 用 { … }   包着，在IDE 下面会有高亮的提示  ::CoroutineScope hint right after the runBlocking opening curly brace:: 当你在你代码中用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a> 发起了调用，却忘记用 runBlocking包裹时将会出现报错，因为 launch 只能在   <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> 中声明。</p>
<p><strong>runBlocking</strong> 意味着处在这一线程中的（上面例子为主线程）代码在执行的过程中将会被 <strong>blocked</strong>，直到runBlocking { … } 所有的coroutines 完成所有的执行。你会经常看到runBlocking 用在程序中非常靠前的位置，并且很少会在真实的业务代码中看到。这是因为线程是非常昂贵的资源，阻塞它们是很低效且并不是我们想要的结果。</p>
<p>结构化的并发编程</p>
<p>Coroutines 遵循着 <strong>结构化并发的</strong> 的原则，这意味着新的coroutines 只能被特定的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> 发起，它界定了coroutines的生命周期。</p>
<p>上面的例子介绍了 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a> 的使用，它创建了相关的作用域，因此前一个例子中一直等到 延迟一秒后 world 的输出 才结束。</p>
<p>在真实的应用中。我们可能启动多个协程。 结构化的同步确保了它们不会丢失和导致内存泄漏。外部的作用域会等到它内部的子协程结束才退出。</p>
<p>结构化的同步也确保了代码中的所有错误都能正确地被收集下来并不会丢失。</p>
<h3 id="提取函数并重构">提取函数并重构</h3>
<p>让我们把 launch{ ... } 中的代码块提取到一个单独的函数中。当你对这段代码进行 &quot;提取函数 &quot;重构时，你将声明一个带有suspend修改器的新函数。这是你的第一个suspend函数。suspend函数可以像普通函数一样在 coroutine 中使用，但它们的有着suspend特性，它们可以反过来使用其他suspend的函数（如本例中的 delay）来挂起 coroutine 的执行。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

//sampleStart
fun main() = runBlocking { // this: CoroutineScope
    launch { doWorld() }
    println(“Hello”)
}

// this is your first suspending function
suspend fun doWorld() {
    delay(1000L)
    println(“World!”)
}
//sampleEnd
</code></pre>
<h3 id="作用域的构造器">作用域的构造器</h3>
<p>除了自带中的不同构建器所提供scope之外，还可以使用 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a> 构建器来声明自定义的scope。它创建一个coroutine scope，在所有启动的子程序完成之后才会被销毁。</p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a> 和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a> 构建器看起来很相似，因为它们都在等待其主体和所有子程序完成。主要的区别在于 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a>方法会阻塞当前线程并进行等待，而<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>只是暂停，释放底层线程用于其他用途。因为这个区别，<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a>是一个普通的函数，而<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>是一个暂停的函数。</p>
<p>你可以从任何一个suspend函数中使用coroutineScope。例如，你可以将Hello和World的并发打印转移到一个suspend的函数doWorld()中。</p>
<pre><code class="language-kotlin">
import kotlinx.coroutines.*

//sampleStart
fun main() = runBlocking {
    doWorld()
}

suspend fun doWorld() = coroutineScope {  // this: CoroutineScope
    launch {
        delay(1000L)
        println(“World!”)
    }
    println(“Hello”)
}
//sampleEnd
</code></pre>
<p>代码输出结果</p>
<pre><code>Hello
World!
</code></pre>
<h3 id="作用域构造器和并发">作用域构造器和并发</h3>
<p>一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>构建器可以用在任何suspend函数中，以执行多个并发的操作。让我们在一个doWorld 的suspend函数中启动两个并发的coroutine。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

//sampleStart
// Sequentially executes doWorld followed by “Done”
fun main() = runBlocking {
    doWorld()
    println(“Done”)
}

// Concurrently executes both sections
suspend fun doWorld() = coroutineScope { // this: CoroutineScope
    launch {
        delay(2000L)
        println(“World 2”)
    }
    launch {
        delay(1000L)
        println(“World 1”)
    }
    println(“Hello”)
}
//sampleEnd
</code></pre>
<p>launch { ... }块内的两段代码都是同时执行的，从开始的一秒钟后，先打印<em>World 1</em>，从开始的两秒钟后，接着打印 <em>World 2</em>。doWorld 中的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>只有在这两段代码完成后才会完成，所以doWorld返回并在这之后打印 <em>Done</em>。</p>
<h3 id="显式的job">显式的Job</h3>
<p>一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a> coroutine builder 会返回一个 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a> 对象，该对象是启动的 coroutine 的句柄，可以用来明确地等待其完成。例如，你可以等待子循环程序的完成，然后打印 <em>Done</em> 。</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch { // launch a new coroutine and keep a reference to its Job
        delay(1000L)
        println(“World!”)
    }
    println(“Hello”)
    job.join() // wait until child coroutine completes
    println(“Done”) 
//sampleEnd    
}
</code></pre>
<p>代码输出结果</p>
<pre><code>Hello
World!
Done
</code></pre>
<h3 id="相当轻量化的coroutines">相当轻量化的Coroutines</h3>
<p>执行以下代码：</p>
<pre><code class="language-kotlin">import kotlinx.coroutines.*

//sampleStart
fun main() = runBlocking {
    repeat(100_000) { // launch a lot of coroutines
        launch {
            delay(5000L)
            print(“.”)
        }
    }
}
//sampleEnd
</code></pre>
<p>它启动了100K个coroutines，5秒钟后，每个coroutine打印一个点。</p>
<p>现在，用线程试试（去掉<em>runBlocking</em>，用线程代替协程启动，用 <em>Thread.sleep</em>代替延迟）。会发生什么？(很可能你的代码会产生内存不足的错误)</p>
<h3 id="参考文献">参考文献</h3>
<p><a href="https://kotlinlang.org/docs/coroutines-basics.html#your-first-coroutine">Coroutines basics</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://waltcow.github.io/post/about/</id>
        <link href="https://waltcow.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>一些coding的碎碎念</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>编程，电影，尝试写点东西</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p><a href="mailto:waltcow@gmail.com">Email</a></p>
<p><a href="https://github.com/waltcow">Github</a></p>
]]></content>
    </entry>
</feed>